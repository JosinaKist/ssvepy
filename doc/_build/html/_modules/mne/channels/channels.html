<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mne.channels.channels &#8212; ssvepy 0.2 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          ssvepy</a>
        <span class="navbar-text navbar-version pull-left"><b>0.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <h1>Source code for mne.channels.channels</h1><div class="highlight"><pre>
<span></span><span class="c1"># Authors: Alexandre Gramfort &lt;alexandre.gramfort@telecom-paristech.fr&gt;</span>
<span class="c1">#          Matti Hamalainen &lt;msh@nmr.mgh.harvard.edu&gt;</span>
<span class="c1">#          Denis Engemann &lt;denis.engemann@gmail.com&gt;</span>
<span class="c1">#          Andrew Dykstra &lt;andrew.r.dykstra@gmail.com&gt;</span>
<span class="c1">#          Teon Brooks &lt;teon.brooks@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1"># License: BSD (3-clause)</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">op</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>

<span class="kn">from</span> <span class="nn">..externals.six</span> <span class="k">import</span> <span class="n">string_types</span>

<span class="kn">from</span> <span class="nn">..utils</span> <span class="k">import</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">warn</span><span class="p">,</span> <span class="n">copy_function_doc_to_method_doc</span>
<span class="kn">from</span> <span class="nn">..io.compensator</span> <span class="k">import</span> <span class="n">get_current_comp</span>
<span class="kn">from</span> <span class="nn">..io.constants</span> <span class="k">import</span> <span class="n">FIFF</span>
<span class="kn">from</span> <span class="nn">..io.meas_info</span> <span class="k">import</span> <span class="n">anonymize_info</span>
<span class="kn">from</span> <span class="nn">..io.pick</span> <span class="k">import</span> <span class="p">(</span><span class="n">channel_type</span><span class="p">,</span> <span class="n">pick_info</span><span class="p">,</span> <span class="n">pick_types</span><span class="p">,</span>
                       <span class="n">_check_excludes_includes</span><span class="p">,</span> <span class="n">_PICK_TYPES_KEYS</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_meg_system</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Educated guess for the helmet type based on channels.&quot;&quot;&quot;</span>
    <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;306m&#39;</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_MEG_CH</span><span class="p">:</span>
            <span class="c1"># Only take first 16 bits, as higher bits store CTF grad comp order</span>
            <span class="n">coil_type</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span>
            <span class="k">if</span> <span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_NM_122</span><span class="p">:</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;122m&#39;</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">coil_type</span> <span class="o">//</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># All Vectorview coils are 30xx</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;306m&#39;</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_MAGNES_MAG</span> <span class="ow">or</span>
                  <span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_MAGNES_GRAD</span><span class="p">):</span>
                <span class="n">nmag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_MEG_CH</span>
                               <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">]])</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;Magnes_3600wh&#39;</span> <span class="k">if</span> <span class="n">nmag</span> <span class="o">&gt;</span> <span class="mi">150</span> <span class="k">else</span> <span class="s1">&#39;Magnes_2500wh&#39;</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_CTF_GRAD</span><span class="p">:</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;CTF_275&#39;</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_KIT_GRAD</span><span class="p">:</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;KIT&#39;</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_BABY_GRAD</span><span class="p">:</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;BabySQUID&#39;</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="n">system</span>


<span class="k">def</span> <span class="nf">_contains_ch_type</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check whether a certain channel type is in an info object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : instance of Info</span>
<span class="sd">        The measurement information.</span>
<span class="sd">    ch_type : str</span>
<span class="sd">        the channel type to be checked for</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    has_ch_type : bool</span>
<span class="sd">        Whether the channel type is present or not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_type</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`ch_type` is of class </span><span class="si">{actual_class}</span><span class="s1">. It must be &#39;</span>
                         <span class="s1">&#39;`str`&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">actual_class</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">ch_type</span><span class="p">)))</span>

    <span class="n">meg_extras</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mag&#39;</span><span class="p">,</span> <span class="s1">&#39;grad&#39;</span><span class="p">,</span> <span class="s1">&#39;planar1&#39;</span><span class="p">,</span> <span class="s1">&#39;planar2&#39;</span><span class="p">]</span>
    <span class="n">fnirs_extras</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;hbo&#39;</span><span class="p">,</span> <span class="s1">&#39;hbr&#39;</span><span class="p">]</span>
    <span class="n">valid_channel_types</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_PICK_TYPES_KEYS</span>
                                  <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;meg&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">meg_extras</span> <span class="o">+</span> <span class="n">fnirs_extras</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ch_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_channel_types</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ch_type must be one of </span><span class="si">%s</span><span class="s1">, not &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">valid_channel_types</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot check for channels of type &quot;</span><span class="si">%s</span><span class="s1">&quot; because info &#39;</span>
                         <span class="s1">&#39;is None&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ch_type</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">ch_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">channel_type</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">])]</span>


<span class="k">def</span> <span class="nf">_get_ch_type</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Choose a single channel type (usually for plotting).</span>

<span class="sd">    Usually used in plotting to plot a single datatype, e.g. look for mags,</span>
<span class="sd">    then grads, then ... to plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ch_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mag&#39;</span><span class="p">,</span> <span class="s1">&#39;grad&#39;</span><span class="p">,</span> <span class="s1">&#39;planar1&#39;</span><span class="p">,</span> <span class="s1">&#39;planar2&#39;</span><span class="p">,</span> <span class="s1">&#39;eeg&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">type_</span> <span class="ow">in</span> <span class="n">inst</span><span class="p">:</span>
                <span class="n">ch_type</span> <span class="o">=</span> <span class="n">type_</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No plottable channel types found&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ch_type</span>


<span class="nd">@verbose</span>
<span class="k">def</span> <span class="nf">equalize_channels</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Equalize channel picks for a collection of MNE-Python objects.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    candidates : list</span>
<span class="sd">        list Raw | Epochs | Evoked | AverageTFR</span>
<span class="sd">    verbose : bool, str, int, or None</span>
<span class="sd">        If not None, override default verbose level (see :func:`mne.verbose`</span>
<span class="sd">        and :ref:`Logging documentation &lt;tut_logging&gt;` for more).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function operates inplace.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..io.base</span> <span class="k">import</span> <span class="n">BaseRaw</span>
    <span class="kn">from</span> <span class="nn">..epochs</span> <span class="k">import</span> <span class="n">BaseEpochs</span>
    <span class="kn">from</span> <span class="nn">..evoked</span> <span class="k">import</span> <span class="n">Evoked</span>
    <span class="kn">from</span> <span class="nn">..time_frequency</span> <span class="k">import</span> <span class="n">AverageTFR</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseRaw</span><span class="p">,</span> <span class="n">BaseEpochs</span><span class="p">,</span> <span class="n">Evoked</span><span class="p">,</span> <span class="n">AverageTFR</span><span class="p">))</span>
               <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;candidates must be Raw, Epochs, Evoked, or &#39;</span>
                         <span class="s1">&#39;AverageTFR&#39;</span><span class="p">)</span>

    <span class="n">chan_max_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">])</span>
    <span class="n">chan_template</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">chan_max_idx</span><span class="p">]</span><span class="o">.</span><span class="n">ch_names</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Identiying common channels ...&#39;</span><span class="p">)</span>
    <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ch_names</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">]</span>
    <span class="n">common_channels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chan_template</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">channels</span><span class="p">)</span>
    <span class="n">dropped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
        <span class="n">drop_them</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">-</span> <span class="n">common_channels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_them</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">drop_channels</span><span class="p">(</span><span class="n">drop_them</span><span class="p">)</span>
            <span class="n">dropped</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">drop_them</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dropped</span><span class="p">:</span>
        <span class="n">dropped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dropped</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Dropped the following channels:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">dropped</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;all channels are corresponding, nothing to do.&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ContainsMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin class for Raw, Evoked, Epochs.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check channel type membership.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ch_type : str</span>
<span class="sd">            Channel type to check for. Can be e.g. &#39;meg&#39;, &#39;eeg&#39;, &#39;stim&#39;, etc.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        in : bool</span>
<span class="sd">            Whether or not the instance contains the given channel type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Channel type membership can be tested as::</span>

<span class="sd">            &gt;&gt;&gt; &#39;meg&#39; in inst  # doctest: +SKIP</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; &#39;seeg&#39; in inst  # doctest: +SKIP</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;meg&#39;</span><span class="p">:</span>
            <span class="n">has_ch_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">_contains_ch_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s1">&#39;mag&#39;</span><span class="p">)</span> <span class="ow">or</span>
                           <span class="n">_contains_ch_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s1">&#39;grad&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">has_ch_type</span> <span class="o">=</span> <span class="n">_contains_ch_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">has_ch_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">compensation_grade</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The current gradient compensation grade.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_current_comp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>


<span class="c1"># XXX Eventually de-duplicate with _kind_dict of mne/io/meas_info.py</span>
<span class="n">_human2fiff</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ecg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_ECG_CH</span><span class="p">,</span>
               <span class="s1">&#39;eeg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_EEG_CH</span><span class="p">,</span>
               <span class="s1">&#39;emg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_EMG_CH</span><span class="p">,</span>
               <span class="s1">&#39;eog&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_EOG_CH</span><span class="p">,</span>
               <span class="s1">&#39;exci&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_EXCI_CH</span><span class="p">,</span>
               <span class="s1">&#39;ias&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_IAS_CH</span><span class="p">,</span>
               <span class="s1">&#39;misc&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_MISC_CH</span><span class="p">,</span>
               <span class="s1">&#39;resp&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_RESP_CH</span><span class="p">,</span>
               <span class="s1">&#39;seeg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_SEEG_CH</span><span class="p">,</span>
               <span class="s1">&#39;stim&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_STIM_CH</span><span class="p">,</span>
               <span class="s1">&#39;syst&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_SYST_CH</span><span class="p">,</span>
               <span class="s1">&#39;bio&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_BIO_CH</span><span class="p">,</span>
               <span class="s1">&#39;ecog&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_ECOG_CH</span><span class="p">,</span>
               <span class="s1">&#39;hbo&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_FNIRS_CH</span><span class="p">,</span>
               <span class="s1">&#39;hbr&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_FNIRS_CH</span><span class="p">}</span>
<span class="n">_human2unit</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ecg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;eeg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;emg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;eog&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;exci&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_NONE</span><span class="p">,</span>
               <span class="s1">&#39;ias&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_NONE</span><span class="p">,</span>
               <span class="s1">&#39;misc&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;resp&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_NONE</span><span class="p">,</span>
               <span class="s1">&#39;seeg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;stim&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_NONE</span><span class="p">,</span>
               <span class="s1">&#39;syst&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_NONE</span><span class="p">,</span>
               <span class="s1">&#39;bio&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;ecog&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;hbo&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_MOL</span><span class="p">,</span>
               <span class="s1">&#39;hbr&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_MOL</span><span class="p">}</span>
<span class="n">_unit2human</span> <span class="o">=</span> <span class="p">{</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">:</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span>
               <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_T</span><span class="p">:</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span>
               <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_T_M</span><span class="p">:</span> <span class="s1">&#39;T/m&#39;</span><span class="p">,</span>
               <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_MOL</span><span class="p">:</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span>
               <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_NONE</span><span class="p">:</span> <span class="s1">&#39;NA&#39;</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">_check_set</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">projs</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ensure type change is compatible with projectors.&quot;&quot;&quot;</span>
    <span class="n">new_kind</span> <span class="o">=</span> <span class="n">_human2fiff</span><span class="p">[</span><span class="n">ch_type</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new_kind</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">proj</span> <span class="ow">in</span> <span class="n">projs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;ch_name&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;col_names&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot change channel type for channel </span><span class="si">%s</span><span class="s1"> &#39;</span>
                                   <span class="s1">&#39;in projector &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span>
                                   <span class="o">%</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;ch_name&#39;</span><span class="p">],</span> <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;desc&#39;</span><span class="p">]))</span>
    <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_kind</span>


<span class="k">class</span> <span class="nc">SetChannelsMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin class for Raw, Evoked, Epochs.&quot;&quot;&quot;</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">set_eeg_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specify which reference to use for EEG data.</span>

<span class="sd">        By default, MNE-Python will automatically re-reference the EEG signal</span>
<span class="sd">        to use an average reference (see below). Use this function to</span>
<span class="sd">        explicitly specify the desired reference for EEG. This can be either an</span>
<span class="sd">        existing electrode or a new virtual channel. This function will</span>
<span class="sd">        re-reference the data according to the desired reference and prevent</span>
<span class="sd">        MNE-Python from automatically adding an average reference.</span>

<span class="sd">        Some common referencing schemes and the corresponding value for the</span>
<span class="sd">        ``ref_channels`` parameter:</span>

<span class="sd">        No re-referencing:</span>
<span class="sd">            If the EEG data is already using the proper reference, set</span>
<span class="sd">            ``ref_channels=[]``. This will prevent MNE-Python from</span>
<span class="sd">            automatically re-referencing the data to an average reference.</span>

<span class="sd">        Average reference:</span>
<span class="sd">            A new virtual reference electrode is created by averaging the</span>
<span class="sd">            current EEG signal. Make sure that all bad EEG channels are</span>
<span class="sd">            properly marked and set ``ref_channels=None``.</span>

<span class="sd">        A single electrode:</span>
<span class="sd">            Set ``ref_channels`` to the name of the channel that will act as</span>
<span class="sd">            the new reference.</span>

<span class="sd">        The mean of multiple electrodes:</span>
<span class="sd">            A new virtual reference electrode is created by computing the</span>
<span class="sd">            average of the current EEG signal recorded from two or more</span>
<span class="sd">            selected channels. Set ``ref_channels`` to a list of channel names,</span>
<span class="sd">            indicating which channels to use. For example, to apply an average</span>
<span class="sd">            mastoid reference, when using the 10-20 naming scheme, set</span>
<span class="sd">            ``ref_channels=[&#39;M1&#39;, &#39;M2&#39;]``.</span>

<span class="sd">        .. note:: In case of average reference (ref_channels=None), the</span>
<span class="sd">                  reference is added as an SSP projector and it is not applied</span>
<span class="sd">                  automatically. For it to take effect, apply with method</span>
<span class="sd">                  :meth:`apply_proj &lt;mne.io.Raw.apply_proj&gt;`.</span>
<span class="sd">                  For custom reference (ref_channel is not None), this method</span>
<span class="sd">                  operates in place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ref_channels : list of str | None</span>
<span class="sd">            The names of the channels to use to construct the reference. If</span>
<span class="sd">            None (default), an average reference will be added as an SSP</span>
<span class="sd">            projector but not immediately applied to the data. If an empty list</span>
<span class="sd">            is specified, the data is assumed to already have a proper</span>
<span class="sd">            reference and MNE will not attempt any re-referencing of the data.</span>
<span class="sd">            Defaults to an average reference (None).</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw | Epochs | Evoked</span>
<span class="sd">            Data with EEG channels re-referenced. For ``ref_channels=None``,</span>
<span class="sd">            an average projector will be added instead of directly subtarcting</span>
<span class="sd">            data.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        1. If a reference is requested that is not the average reference, this</span>
<span class="sd">           function removes any pre-existing average reference projections.</span>

<span class="sd">        2. During source localization, the EEG signal should have an average</span>
<span class="sd">           reference.</span>

<span class="sd">        3. In order to apply a reference other than an average reference, the</span>
<span class="sd">           data must be preloaded.</span>

<span class="sd">        4. Re-referencing to an average reference is done with an SSP</span>
<span class="sd">           projector. This allows applying this reference without preloading</span>
<span class="sd">           the data. Be aware that on preloaded data, SSP projectors are not</span>
<span class="sd">           automatically applied. Use the ``apply_proj()`` method to apply</span>
<span class="sd">           them.</span>

<span class="sd">        .. versionadded:: 0.13.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mne.set_bipolar_reference</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..io.reference</span> <span class="k">import</span> <span class="n">set_eeg_reference</span>
        <span class="k">return</span> <span class="n">set_eeg_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_channels</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_channel_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get channel locations from info.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        picks : array-like of int | None</span>
<span class="sd">            Indices of channels to include. If None (default), all meg and eeg</span>
<span class="sd">            channels that are available are returned (bad channels excluded).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">pick_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">chs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">chs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">])</span>
        <span class="n">n_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_zero</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># XXX some systems have origin (0, 0, 0)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not extract channel positions for &#39;</span>
                             <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> channels&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_zero</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">_set_channel_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update channel locations in info.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pos : array-like | np.ndarray, shape (n_points, 3)</span>
<span class="sd">            The channel positions to be set.</span>
<span class="sd">        names : list of str</span>
<span class="sd">            The names of the channels to be set.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of channel positions not equal to &#39;</span>
                             <span class="s1">&#39;the number of names given.&#39;</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">pos</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Channel positions must have the shape (n_points, 3) &#39;</span>
                   <span class="s1">&#39;not </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> was not found in the info. Cannot be updated.&#39;</span>
                       <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_channel_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define the sensor type of channels.</span>

<span class="sd">        Note: The following sensor types are accepted:</span>
<span class="sd">            ecg, eeg, emg, eog, exci, ias, misc, resp, seeg, stim, syst, ecog,</span>
<span class="sd">            hbo, hbr</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapping : dict</span>
<span class="sd">            a dictionary mapping a channel to a sensor type (str)</span>
<span class="sd">            {&#39;EEG061&#39;: &#39;eog&#39;}.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]</span>

        <span class="c1"># first check and assemble clean mappings of index and name</span>
        <span class="n">unit_changes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ch_name</span><span class="p">,</span> <span class="n">ch_type</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ch_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ch_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This channel name (</span><span class="si">%s</span><span class="s2">) doesn&#39;t exist in &quot;</span>
                                 <span class="s2">&quot;info.&quot;</span> <span class="o">%</span> <span class="n">ch_name</span><span class="p">)</span>

            <span class="n">c_ind</span> <span class="o">=</span> <span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ch_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ch_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_human2fiff</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;This function cannot change to this &#39;</span>
                                 <span class="s1">&#39;channel type: </span><span class="si">%s</span><span class="s1">. Accepted channel types &#39;</span>
                                 <span class="s1">&#39;are </span><span class="si">%s</span><span class="s1">.&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">ch_type</span><span class="p">,</span>
                                    <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">_human2unit</span><span class="o">.</span><span class="n">keys</span><span class="p">()))))</span>
            <span class="c1"># Set sensor type</span>
            <span class="n">_check_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">c_ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">],</span> <span class="n">ch_type</span><span class="p">)</span>
            <span class="n">unit_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">c_ind</span><span class="p">][</span><span class="s1">&#39;unit&#39;</span><span class="p">]</span>
            <span class="n">unit_new</span> <span class="o">=</span> <span class="n">_human2unit</span><span class="p">[</span><span class="n">ch_type</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">unit_old</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_unit2human</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Channel &#39;</span><span class="si">%s</span><span class="s2">&#39; has unknown unit (</span><span class="si">%s</span><span class="s2">). Please &quot;</span>
                                 <span class="s2">&quot;fix the measurement info of your data.&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">ch_name</span><span class="p">,</span> <span class="n">unit_old</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">unit_old</span> <span class="o">!=</span> <span class="n">_human2unit</span><span class="p">[</span><span class="n">ch_type</span><span class="p">]:</span>
                <span class="n">this_change</span> <span class="o">=</span> <span class="p">(</span><span class="n">_unit2human</span><span class="p">[</span><span class="n">unit_old</span><span class="p">],</span> <span class="n">_unit2human</span><span class="p">[</span><span class="n">unit_new</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">this_change</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unit_changes</span><span class="p">:</span>
                    <span class="n">unit_changes</span><span class="p">[</span><span class="n">this_change</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="n">unit_changes</span><span class="p">[</span><span class="n">this_change</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">c_ind</span><span class="p">][</span><span class="s1">&#39;unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_human2unit</span><span class="p">[</span><span class="n">ch_type</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ch_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;eeg&#39;</span><span class="p">,</span> <span class="s1">&#39;seeg&#39;</span><span class="p">,</span> <span class="s1">&#39;ecog&#39;</span><span class="p">]:</span>
                <span class="n">coil_type</span> <span class="o">=</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_EEG</span>
            <span class="k">elif</span> <span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;hbo&#39;</span><span class="p">:</span>
                <span class="n">coil_type</span> <span class="o">=</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_FNIRS_HBO</span>
            <span class="k">elif</span> <span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;hbr&#39;</span><span class="p">:</span>
                <span class="n">coil_type</span> <span class="o">=</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_FNIRS_HBR</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coil_type</span> <span class="o">=</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_NONE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">c_ind</span><span class="p">][</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coil_type</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The unit for channel(s) </span><span class="si">{0}</span><span class="s2"> has changed from </span><span class="si">{1}</span><span class="s2"> to </span><span class="si">{2}</span><span class="s2">.&quot;</span>
        <span class="k">for</span> <span class="n">this_change</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">unit_changes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">names</span><span class="p">)),</span> <span class="o">*</span><span class="n">this_change</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rename_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename channels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapping : dict | callable</span>
<span class="sd">            a dictionary mapping the old channel to a new channel name</span>
<span class="sd">            e.g. {&#39;EEG061&#39; : &#39;EEG161&#39;}. Can also be a callable function</span>
<span class="sd">            that takes and returns a string (new in version 0.10.0).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rename_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">set_montage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">montage</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set EEG sensor configuration and head digitization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        montage : instance of Montage or DigMontage</span>
<span class="sd">            The montage to use.</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Operates in place.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.montage</span> <span class="k">import</span> <span class="n">_set_montage</span>
        <span class="n">_set_montage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">montage</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">plot_sensors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;topomap&#39;</span><span class="p">,</span> <span class="n">ch_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">show_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ch_groups</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_sphere</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot sensor positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kind : str</span>
<span class="sd">            Whether to plot the sensors as 3d, topomap or as an interactive</span>
<span class="sd">            sensor selection dialog. Available options &#39;topomap&#39;, &#39;3d&#39;,</span>
<span class="sd">            &#39;select&#39;. If &#39;select&#39;, a set of channels can be selected</span>
<span class="sd">            interactively by using lasso selector or clicking while holding</span>
<span class="sd">            control key. The selected channels are returned along with the</span>
<span class="sd">            figure instance. Defaults to &#39;topomap&#39;.</span>
<span class="sd">        ch_type : None | str</span>
<span class="sd">            The channel type to plot. Available options &#39;mag&#39;, &#39;grad&#39;, &#39;eeg&#39;,</span>
<span class="sd">            &#39;seeg&#39;, &#39;ecog&#39;, &#39;all&#39;. If ``&#39;all&#39;``, all the available mag, grad,</span>
<span class="sd">            eeg, seeg and ecog channels are plotted. If None (default), then</span>
<span class="sd">            channels are chosen in the order given above.</span>
<span class="sd">        title : str | None</span>
<span class="sd">            Title for the figure. If None (default), equals to ``&#39;Sensor</span>
<span class="sd">            positions (%s)&#39; % ch_type``.</span>
<span class="sd">        show_names : bool | array of str</span>
<span class="sd">            Whether to display all channel names. If an array, only the channel</span>
<span class="sd">            names in the array are shown. Defaults to False.</span>
<span class="sd">        ch_groups : &#39;position&#39; | array of shape (ch_groups, picks) | None</span>
<span class="sd">            Channel groups for coloring the sensors. If None (default), default</span>
<span class="sd">            coloring scheme is used. If &#39;position&#39;, the sensors are divided</span>
<span class="sd">            into 8 regions. See ``order`` kwarg of :func:`mne.viz.plot_raw`. If</span>
<span class="sd">            array, the channels are divided by picks given in the array.</span>

<span class="sd">            .. versionadded:: 0.13.0</span>

<span class="sd">        to_sphere : bool</span>
<span class="sd">            Whether to project the 3d locations to a sphere. When False, the</span>
<span class="sd">            sensor array appears similar as to looking downwards straight above</span>
<span class="sd">            the subject&#39;s head. Has no effect when kind=&#39;3d&#39;. Defaults to True.</span>

<span class="sd">            .. versionadded:: 0.14.0</span>

<span class="sd">        axes : instance of Axes | instance of Axes3D | None</span>
<span class="sd">            Axes to draw the sensors to. If ``kind=&#39;3d&#39;``, axes must be an</span>
<span class="sd">            instance of Axes3D. If None (default), a new axes will be created.</span>

<span class="sd">            .. versionadded:: 0.13.0</span>

<span class="sd">        block : bool</span>
<span class="sd">            Whether to halt program execution until the figure is closed.</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">            .. versionadded:: 0.13.0</span>

<span class="sd">        show : bool</span>
<span class="sd">            Show figure if True. Defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : instance of matplotlib figure</span>
<span class="sd">            Figure containing the sensor topography.</span>
<span class="sd">        selection : list</span>
<span class="sd">            A list of selected channels. Only returned if ``kind==&#39;select&#39;``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mne.viz.plot_layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function plots the sensor locations from the info structure using</span>
<span class="sd">        matplotlib. For drawing the sensors using mayavi see</span>
<span class="sd">        :func:`mne.viz.plot_trans`.</span>

<span class="sd">        .. versionadded:: 0.12.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..viz.utils</span> <span class="k">import</span> <span class="n">plot_sensors</span>
        <span class="k">return</span> <span class="n">plot_sensors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">ch_type</span><span class="o">=</span><span class="n">ch_type</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                            <span class="n">show_names</span><span class="o">=</span><span class="n">show_names</span><span class="p">,</span> <span class="n">ch_groups</span><span class="o">=</span><span class="n">ch_groups</span><span class="p">,</span>
                            <span class="n">to_sphere</span><span class="o">=</span><span class="n">to_sphere</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                            <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">)</span>

    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">anonymize_info</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">anonymize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.13.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">anonymize_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">UpdateChannelsMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin class for Raw, Evoked, Epochs, AverageTFR.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">pick_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">ecg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">emg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ref_meg</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">misc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">resp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chpi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exci</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">syst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">seeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dipole</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gof</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bio</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ecog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">fnirs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="p">(),</span> <span class="n">exclude</span><span class="o">=</span><span class="s1">&#39;bads&#39;</span><span class="p">,</span> <span class="n">selection</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pick some channels by type and names.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meg : bool | str</span>
<span class="sd">            If True include all MEG channels. If False include None</span>
<span class="sd">            If string it can be &#39;mag&#39;, &#39;grad&#39;, &#39;planar1&#39; or &#39;planar2&#39; to select</span>
<span class="sd">            only magnetometers, all gradiometers, or a specific type of</span>
<span class="sd">            gradiometer.</span>
<span class="sd">        eeg : bool</span>
<span class="sd">            If True include EEG channels.</span>
<span class="sd">        stim : bool</span>
<span class="sd">            If True include stimulus channels.</span>
<span class="sd">        eog : bool</span>
<span class="sd">            If True include EOG channels.</span>
<span class="sd">        ecg : bool</span>
<span class="sd">            If True include ECG channels.</span>
<span class="sd">        emg : bool</span>
<span class="sd">            If True include EMG channels.</span>
<span class="sd">        ref_meg: bool | str</span>
<span class="sd">            If True include CTF / 4D reference channels. If &#39;auto&#39;, the</span>
<span class="sd">            reference channels are only included if compensations are present.</span>
<span class="sd">        misc : bool</span>
<span class="sd">            If True include miscellaneous analog channels.</span>
<span class="sd">        resp : bool</span>
<span class="sd">            If True include response-trigger channel. For some MEG systems this</span>
<span class="sd">            is separate from the stim channel.</span>
<span class="sd">        chpi : bool</span>
<span class="sd">            If True include continuous HPI coil channels.</span>
<span class="sd">        exci : bool</span>
<span class="sd">            Flux excitation channel used to be a stimulus channel.</span>
<span class="sd">        ias : bool</span>
<span class="sd">            Internal Active Shielding data (maybe on Triux only).</span>
<span class="sd">        syst : bool</span>
<span class="sd">            System status channel information (on Triux systems only).</span>
<span class="sd">        seeg : bool</span>
<span class="sd">            Stereotactic EEG channels.</span>
<span class="sd">        dipole : bool</span>
<span class="sd">            Dipole time course channels.</span>
<span class="sd">        gof : bool</span>
<span class="sd">            Dipole goodness of fit channels.</span>
<span class="sd">        bio : bool</span>
<span class="sd">            Bio channels.</span>
<span class="sd">        ecog : bool</span>
<span class="sd">            Electrocorticography channels.</span>
<span class="sd">        fnirs : bool | str</span>
<span class="sd">            Functional near-infrared spectroscopy channels. If True include all</span>
<span class="sd">            fNIRS channels. If False (default) include none. If string it can</span>
<span class="sd">            be &#39;hbo&#39; (to include channels measuring oxyhemoglobin) or &#39;hbr&#39; (to</span>
<span class="sd">            include channels measuring deoxyhemoglobin).</span>
<span class="sd">        include : list of string</span>
<span class="sd">            List of additional channels to include. If empty do not include</span>
<span class="sd">            any.</span>
<span class="sd">        exclude : list of string | str</span>
<span class="sd">            List of channels to exclude. If &#39;bads&#39; (default), exclude channels</span>
<span class="sd">            in ``info[&#39;bads&#39;]``.</span>
<span class="sd">        selection : list of string</span>
<span class="sd">            Restrict sensor channels (MEG, EEG) to this list of channel names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw, Epochs, or Evoked</span>
<span class="sd">            The modified instance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">pick_types</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="n">meg</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="n">eeg</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="n">stim</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="n">eog</span><span class="p">,</span> <span class="n">ecg</span><span class="o">=</span><span class="n">ecg</span><span class="p">,</span> <span class="n">emg</span><span class="o">=</span><span class="n">emg</span><span class="p">,</span>
            <span class="n">ref_meg</span><span class="o">=</span><span class="n">ref_meg</span><span class="p">,</span> <span class="n">misc</span><span class="o">=</span><span class="n">misc</span><span class="p">,</span> <span class="n">resp</span><span class="o">=</span><span class="n">resp</span><span class="p">,</span> <span class="n">chpi</span><span class="o">=</span><span class="n">chpi</span><span class="p">,</span> <span class="n">exci</span><span class="o">=</span><span class="n">exci</span><span class="p">,</span>
            <span class="n">ias</span><span class="o">=</span><span class="n">ias</span><span class="p">,</span> <span class="n">syst</span><span class="o">=</span><span class="n">syst</span><span class="p">,</span> <span class="n">seeg</span><span class="o">=</span><span class="n">seeg</span><span class="p">,</span> <span class="n">dipole</span><span class="o">=</span><span class="n">dipole</span><span class="p">,</span> <span class="n">gof</span><span class="o">=</span><span class="n">gof</span><span class="p">,</span> <span class="n">bio</span><span class="o">=</span><span class="n">bio</span><span class="p">,</span>
            <span class="n">ecog</span><span class="o">=</span><span class="n">ecog</span><span class="p">,</span> <span class="n">fnirs</span><span class="o">=</span><span class="n">fnirs</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="n">include</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">,</span>
            <span class="n">selection</span><span class="o">=</span><span class="n">selection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pick_drop_channels</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">pick_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pick some channels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ch_names : list</span>
<span class="sd">            The list of channels to select.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw, Epochs, or Evoked</span>
<span class="sd">            The modified instance.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        drop_channels</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_excludes_includes</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ch_names</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pick_drop_channels</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">drop_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drop some channels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ch_names : list</span>
<span class="sd">            List of the names of the channels to remove.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw, Epochs, or Evoked</span>
<span class="sd">            The modified instance.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pick_channels</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&#39;ch_names&#39; should be a list of strings (the name[s] of the &quot;</span>
               <span class="s2">&quot;channel to be dropped), not a </span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_names</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_name</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">ch_name</span> <span class="ow">in</span> <span class="n">ch_names</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ch_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch_name</span> <span class="k">for</span> <span class="n">ch_name</span> <span class="ow">in</span> <span class="n">ch_names</span>
                   <span class="k">if</span> <span class="n">ch_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Channel(s) </span><span class="si">{0}</span><span class="s2"> not found, nothing dropped.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing</span><span class="p">)))</span>

        <span class="n">bad_idx</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ch_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch_name</span> <span class="ow">in</span> <span class="n">ch_names</span>
                   <span class="k">if</span> <span class="n">ch_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">)),</span> <span class="n">bad_idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pick_drop_channels</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_pick_drop_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="c1"># avoid circular imports</span>
        <span class="kn">from</span> <span class="nn">..io.base</span> <span class="k">import</span> <span class="n">_check_preload</span>
        <span class="kn">from</span> <span class="nn">..time_frequency</span> <span class="k">import</span> <span class="n">AverageTFR</span>

        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;adding or dropping channels&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;picks&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_cals&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">pick_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_projector&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_projector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projector</span><span class="p">[</span><span class="n">idx</span><span class="p">][:,</span> <span class="n">idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="c1"># All others (Evoked, Epochs, Raw) have chs axis=-2</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AverageTFR</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">add_list</span><span class="p">,</span> <span class="n">force_update_info</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append new channels to the instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        add_list : list</span>
<span class="sd">            A list of objects to append to self. Must contain all the same</span>
<span class="sd">            type as the current object</span>
<span class="sd">        force_update_info : bool</span>
<span class="sd">            If True, force the info for objects to be appended to match the</span>
<span class="sd">            values in `self`. This should generally only be used when adding</span>
<span class="sd">            stim channels for which important metadata won&#39;t be overwritten.</span>

<span class="sd">            .. versionadded:: 0.12</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw, Epochs, or Evoked</span>
<span class="sd">            The modified instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># avoid circular imports</span>
        <span class="kn">from</span> <span class="nn">..io</span> <span class="k">import</span> <span class="n">BaseRaw</span><span class="p">,</span> <span class="n">_merge_info</span>
        <span class="kn">from</span> <span class="nn">..epochs</span> <span class="k">import</span> <span class="n">BaseEpochs</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">add_list</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Input must be a list or tuple of objs&#39;</span><span class="p">)</span>

        <span class="c1"># Object-specific checks</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">inst</span><span class="o">.</span><span class="n">preload</span> <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">add_list</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;All data must be preloaded&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BaseRaw</span><span class="p">):</span>
            <span class="n">con_axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">comp_class</span> <span class="o">=</span> <span class="n">BaseRaw</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BaseEpochs</span><span class="p">):</span>
            <span class="n">con_axis</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">comp_class</span> <span class="o">=</span> <span class="n">BaseEpochs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">con_axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">comp_class</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">comp_class</span><span class="p">)</span> <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">add_list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;All input data must be of same type&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">inst</span><span class="o">.</span><span class="n">_data</span> <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">add_list</span><span class="p">]</span>

        <span class="c1"># Make sure that all dimensions other than channel axis are the same</span>
        <span class="n">compare_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">con_axis</span><span class="p">]</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dat</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">dat</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])[:,</span> <span class="n">compare_axes</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">shapes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;All dimensions except channels must match&#39;</span><span class="p">)</span>

        <span class="c1"># Create final data / info objects</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">con_axis</span><span class="p">)</span>
        <span class="n">infos</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">inst</span><span class="o">.</span><span class="n">info</span> <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">add_list</span><span class="p">]</span>
        <span class="n">new_info</span> <span class="o">=</span> <span class="n">_merge_info</span><span class="p">(</span><span class="n">infos</span><span class="p">,</span> <span class="n">force_update_to_first</span><span class="o">=</span><span class="n">force_update_info</span><span class="p">)</span>

        <span class="c1"># Now update the attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">new_info</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BaseRaw</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="s1">&#39;_cals&#39;</span><span class="p">)</span>
                                         <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">add_list</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">InterpolationMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin class for Raw, Evoked, Epochs.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">interpolate_bads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reset_bads</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;accurate&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate bad MEG and EEG channels.</span>

<span class="sd">        Operates in place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reset_bads : bool</span>
<span class="sd">            If True, remove the bads from info.</span>
<span class="sd">        mode : str</span>
<span class="sd">            Either `&#39;accurate&#39;` or `&#39;fast&#39;`, determines the quality of the</span>
<span class="sd">            Legendre polynomial expansion used for interpolation of MEG</span>
<span class="sd">            channels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw, Epochs, or Evoked</span>
<span class="sd">            The modified instance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.interpolation</span> <span class="k">import</span> <span class="n">_interpolate_bads_eeg</span><span class="p">,</span> <span class="n">_interpolate_bads_meg</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;preload&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Data must be preloaded.&#39;</span><span class="p">)</span>

        <span class="n">_interpolate_bads_eeg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_interpolate_bads_meg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reset_bads</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span>


<span class="k">def</span> <span class="nf">rename_channels</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rename channels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : dict</span>
<span class="sd">        Measurement info.</span>
<span class="sd">    mapping : dict | callable</span>
<span class="sd">        a dictionary mapping the old channel to a new channel name</span>
<span class="sd">        e.g. {&#39;EEG061&#39; : &#39;EEG161&#39;}. Can also be a callable function</span>
<span class="sd">        that takes and returns a string (new in version 0.10.0).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">info</span><span class="o">.</span><span class="n">_check_consistency</span><span class="p">()</span>
    <span class="n">bads</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">])</span>  <span class="c1"># make our own local copies</span>
    <span class="n">ch_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">])</span>

    <span class="c1"># first check and assemble clean mappings of index and name</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">orig_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">orig_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ch_names</span> <span class="k">for</span> <span class="n">orig_name</span> <span class="ow">in</span> <span class="n">orig_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">missing</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Channel name(s) in mapping missing from info: &quot;</span>
                             <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">orig_names</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">missing</span><span class="p">)])</span>
        <span class="n">new_names</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ch_name</span><span class="p">),</span> <span class="n">new_name</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">ch_name</span><span class="p">,</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">mapping</span><span class="p">):</span>
        <span class="n">new_names</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ci</span><span class="p">,</span> <span class="n">mapping</span><span class="p">(</span><span class="n">ch_name</span><span class="p">))</span>
                     <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">ch_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mapping must be callable or dict, not </span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mapping</span><span class="p">),))</span>

    <span class="c1"># check we got all strings out of the mapping</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_name</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">string_types</span><span class="p">)</span>
           <span class="k">for</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">new_names</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;New channel mapping must only be to strings&#39;</span><span class="p">)</span>

    <span class="c1"># do the remapping locally</span>
    <span class="k">for</span> <span class="n">c_ind</span><span class="p">,</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">new_names</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">bi</span><span class="p">,</span> <span class="n">bad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bads</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bad</span> <span class="o">==</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">c_ind</span><span class="p">]:</span>
                <span class="n">bads</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
        <span class="n">ch_names</span><span class="p">[</span><span class="n">c_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>

    <span class="c1"># check that all the channel names are unique</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;New channel names are not unique, renaming failed&#39;</span><span class="p">)</span>

    <span class="c1"># do the reampping in info</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bads</span>
    <span class="k">for</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ch_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">],</span> <span class="n">ch_names</span><span class="p">):</span>
        <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;ch_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_name</span>
    <span class="n">info</span><span class="o">.</span><span class="n">_update_redundant</span><span class="p">()</span>
    <span class="n">info</span><span class="o">.</span><span class="n">_check_consistency</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_recursive_flatten</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unpack mat files in Python.&quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cell</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cell</span>


<span class="k">def</span> <span class="nf">read_ch_connectivity</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse FieldTrip neighbors .mat file.</span>

<span class="sd">    More information on these neighbor definitions can be found on the</span>
<span class="sd">    related FieldTrip documentation pages:</span>
<span class="sd">    http://fieldtrip.fcdonders.nl/template/neighbours</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        The file name. Example: &#39;neuromag306mag&#39;, &#39;neuromag306planar&#39;,</span>
<span class="sd">        &#39;ctf275&#39;, &#39;biosemi64&#39;, etc.</span>
<span class="sd">    picks : array-like of int, shape (n_channels,)</span>
<span class="sd">        The indices of the channels to include. Must match the template.</span>
<span class="sd">        Defaults to None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ch_connectivity : scipy.sparse matrix</span>
<span class="sd">        The connectivity matrix.</span>
<span class="sd">    ch_names : list</span>
<span class="sd">        The list of channel names present in connectivity matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.io</span> <span class="k">import</span> <span class="n">loadmat</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">op</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="n">templates_dir</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span>
                                            <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;neighbors&#39;</span><span class="p">))</span>
        <span class="n">templates</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">templates_dir</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">templates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">fname</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;_neighb.mat&#39;</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">+=</span> <span class="s1">&#39;_neighb.mat&#39;</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;I do not know about this neighbor &#39;</span>
                             <span class="s1">&#39;template: &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">templates_dir</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

    <span class="n">nb</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="s1">&#39;neighbours&#39;</span><span class="p">]</span>
    <span class="n">ch_names</span> <span class="o">=</span> <span class="n">_recursive_flatten</span><span class="p">(</span><span class="n">nb</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">],</span> <span class="n">string_types</span><span class="p">)</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">_recursive_flatten</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span>
                 <span class="n">nb</span><span class="p">[</span><span class="s1">&#39;neighblabel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The picks must be compatible with &#39;</span>
                             <span class="s1">&#39;channels. Found a pick (</span><span class="si">{}</span><span class="s1">) which exceeds &#39;</span>
                             <span class="s1">&#39;the channel range (</span><span class="si">{}</span><span class="s1">)&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">picks</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)))</span>
    <span class="n">connectivity</span> <span class="o">=</span> <span class="n">_ch_neighbor_connectivity</span><span class="p">(</span><span class="n">ch_names</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># picking before constructing matrix is buggy</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">picks</span><span class="p">][:,</span> <span class="n">picks</span><span class="p">]</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch_names</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">connectivity</span><span class="p">,</span> <span class="n">ch_names</span>


<span class="k">def</span> <span class="nf">_ch_neighbor_connectivity</span><span class="p">(</span><span class="n">ch_names</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute sensor connectivity matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ch_names : list of str</span>
<span class="sd">        The channel names.</span>
<span class="sd">    neighbors : list of list</span>
<span class="sd">        A list of list of channel names. The neighbors to</span>
<span class="sd">        which the channels in ch_names are connected with.</span>
<span class="sd">        Must be of the same length as ch_names.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ch_connectivity : scipy.sparse matrix</span>
<span class="sd">        The connectivity matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`ch_names` and `neighbors` must &#39;</span>
                         <span class="s1">&#39;have the same length&#39;</span><span class="p">)</span>
    <span class="n">set_neighbors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">d</span><span class="p">])</span>
    <span class="n">rest</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">-</span> <span class="n">set_neighbors</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Some of your neighbors are not present in the &#39;</span>
                         <span class="s1">&#39;list of channel names&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">neigh</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span>
           <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">neigh</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`neighbors` must be a list of lists of str&#39;</span><span class="p">)</span>

    <span class="n">ch_connectivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">neigbs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
        <span class="n">ch_connectivity</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">[</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">neigbs</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">ch_connectivity</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">ch_connectivity</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ch_connectivity</span>


<span class="k">def</span> <span class="nf">fix_mag_coil_types</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fix magnetometer coil types.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : dict</span>
<span class="sd">        The info dict to correct. Corrections are done in-place.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function changes magnetometer coil types 3022 (T1: SQ20483N) and</span>
<span class="sd">    3023 (T2: SQ20483-A) to 3024 (T3: SQ20950N) in the channel definition</span>
<span class="sd">    records in the info structure.</span>

<span class="sd">    Neuromag Vectorview systems can contain magnetometers with two</span>
<span class="sd">    different coil sizes (3022 and 3023 vs. 3024). The systems</span>
<span class="sd">    incorporating coils of type 3024 were introduced last and are used at</span>
<span class="sd">    the majority of MEG sites. At some sites with 3024 magnetometers,</span>
<span class="sd">    the data files have still defined the magnetometers to be of type</span>
<span class="sd">    3022 to ensure compatibility with older versions of Neuromag software.</span>
<span class="sd">    In the MNE software as well as in the present version of Neuromag</span>
<span class="sd">    software coil type 3024 is fully supported. Therefore, it is now safe</span>
<span class="sd">    to upgrade the data files to use the true coil type.</span>

<span class="sd">    .. note:: The effect of the difference between the coil sizes on the</span>
<span class="sd">              current estimates computed by the MNE software is very small.</span>
<span class="sd">              Therefore the use of mne_fix_mag_coil_types is not mandatory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">old_mag_inds</span> <span class="o">=</span> <span class="n">_get_T1T2_mag_inds</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">old_mag_inds</span><span class="p">:</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_MAG_T3</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> of </span><span class="si">%d</span><span class="s1"> T1/T2 magnetometer types replaced with T3.&#39;</span> <span class="o">%</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_mag_inds</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">pick_types</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">))))</span>
    <span class="n">info</span><span class="o">.</span><span class="n">_check_consistency</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_get_T1T2_mag_inds</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find T1/T2 magnetometer coil types.&quot;&quot;&quot;</span>
    <span class="n">picks</span> <span class="o">=</span> <span class="n">pick_types</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>
    <span class="n">old_mag_inds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">:</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_MAG_T1</span><span class="p">,</span>
                               <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_MAG_T2</span><span class="p">):</span>
            <span class="n">old_mag_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">old_mag_inds</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017, Jan Freyberg.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>