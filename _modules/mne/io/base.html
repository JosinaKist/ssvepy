<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mne.io.base &#8212; ssvepy 0.2 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          ssvepy</a>
        <span class="navbar-text navbar-version pull-left"><b>0.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <h1>Source code for mne.io.base</h1><div class="highlight"><pre>
<span></span><span class="c1"># Authors: Alexandre Gramfort &lt;alexandre.gramfort@telecom-paristech.fr&gt;</span>
<span class="c1">#          Matti Hamalainen &lt;msh@nmr.mgh.harvard.edu&gt;</span>
<span class="c1">#          Martin Luessi &lt;mluessi@nmr.mgh.harvard.edu&gt;</span>
<span class="c1">#          Denis Engemann &lt;denis.engemann@gmail.com&gt;</span>
<span class="c1">#          Teon Brooks &lt;teon.brooks@gmail.com&gt;</span>
<span class="c1">#          Marijn van Vliet &lt;w.m.vanvliet@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1"># License: BSD (3-clause)</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">op</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.constants</span> <span class="k">import</span> <span class="n">FIFF</span>
<span class="kn">from</span> <span class="nn">.pick</span> <span class="k">import</span> <span class="n">pick_types</span><span class="p">,</span> <span class="n">channel_type</span><span class="p">,</span> <span class="n">pick_channels</span><span class="p">,</span> <span class="n">pick_info</span>
<span class="kn">from</span> <span class="nn">.pick</span> <span class="k">import</span> <span class="n">_pick_data_channels</span><span class="p">,</span> <span class="n">_pick_data_or_ica</span>
<span class="kn">from</span> <span class="nn">.meas_info</span> <span class="k">import</span> <span class="n">write_meas_info</span>
<span class="kn">from</span> <span class="nn">.proj</span> <span class="k">import</span> <span class="n">setup_proj</span><span class="p">,</span> <span class="n">activate_proj</span><span class="p">,</span> <span class="n">_proj_equal</span><span class="p">,</span> <span class="n">ProjMixin</span>
<span class="kn">from</span> <span class="nn">..channels.channels</span> <span class="k">import</span> <span class="p">(</span><span class="n">ContainsMixin</span><span class="p">,</span> <span class="n">UpdateChannelsMixin</span><span class="p">,</span>
                                 <span class="n">SetChannelsMixin</span><span class="p">,</span> <span class="n">InterpolationMixin</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..channels.montage</span> <span class="k">import</span> <span class="n">read_montage</span><span class="p">,</span> <span class="n">_set_montage</span><span class="p">,</span> <span class="n">Montage</span>
<span class="kn">from</span> <span class="nn">.compensator</span> <span class="k">import</span> <span class="n">set_current_comp</span><span class="p">,</span> <span class="n">make_compensator</span>
<span class="kn">from</span> <span class="nn">.write</span> <span class="k">import</span> <span class="p">(</span><span class="n">start_file</span><span class="p">,</span> <span class="n">end_file</span><span class="p">,</span> <span class="n">start_block</span><span class="p">,</span> <span class="n">end_block</span><span class="p">,</span>
                    <span class="n">write_dau_pack16</span><span class="p">,</span> <span class="n">write_float</span><span class="p">,</span> <span class="n">write_double</span><span class="p">,</span>
                    <span class="n">write_complex64</span><span class="p">,</span> <span class="n">write_complex128</span><span class="p">,</span> <span class="n">write_int</span><span class="p">,</span>
                    <span class="n">write_id</span><span class="p">,</span> <span class="n">write_string</span><span class="p">,</span> <span class="n">write_name_list</span><span class="p">,</span> <span class="n">_get_split_size</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">..filter</span> <span class="k">import</span> <span class="p">(</span><span class="n">filter_data</span><span class="p">,</span> <span class="n">notch_filter</span><span class="p">,</span> <span class="n">resample</span><span class="p">,</span> <span class="n">next_fast_len</span><span class="p">,</span>
                      <span class="n">_resample_stim_channels</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..parallel</span> <span class="k">import</span> <span class="n">parallel_func</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="k">import</span> <span class="p">(</span><span class="n">_check_fname</span><span class="p">,</span> <span class="n">_check_pandas_installed</span><span class="p">,</span> <span class="n">sizeof_fmt</span><span class="p">,</span>
                     <span class="n">_check_pandas_index_arguments</span><span class="p">,</span>
                     <span class="n">check_fname</span><span class="p">,</span> <span class="n">_get_stim_channel</span><span class="p">,</span>
                     <span class="n">logger</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">_time_mask</span><span class="p">,</span> <span class="n">warn</span><span class="p">,</span> <span class="n">SizeMixin</span><span class="p">,</span>
                     <span class="n">copy_function_doc_to_method_doc</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..viz</span> <span class="k">import</span> <span class="n">plot_raw</span><span class="p">,</span> <span class="n">plot_raw_psd</span><span class="p">,</span> <span class="n">plot_raw_psd_topo</span>
<span class="kn">from</span> <span class="nn">..defaults</span> <span class="k">import</span> <span class="n">_handle_default</span>
<span class="kn">from</span> <span class="nn">..externals.six</span> <span class="k">import</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">..event</span> <span class="k">import</span> <span class="n">find_events</span><span class="p">,</span> <span class="n">concatenate_events</span>
<span class="kn">from</span> <span class="nn">..annotations</span> <span class="k">import</span> <span class="n">Annotations</span><span class="p">,</span> <span class="n">_combine_annotations</span><span class="p">,</span> <span class="n">_sync_onset</span>


<span class="k">class</span> <span class="nc">ToDataFrameMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to add to_data_frame capabilities to certain classes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_get_check_picks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">picks_check</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get and check picks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">picks</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">picks_check</span><span class="p">)))</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one picked channel is not present &#39;</span>
                                 <span class="s1">&#39;in this object instance.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">picks</span>

    <span class="k">def</span> <span class="nf">to_data_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_time</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span>
                      <span class="n">scalings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Export data in tabular structure as a pandas DataFrame.</span>

<span class="sd">        Columns and indices will depend on the object being converted.</span>
<span class="sd">        Generally this will include as much relevant information as</span>
<span class="sd">        possible for the data type being converted. This makes it easy</span>
<span class="sd">        to convert data for use in packages that utilize dataframes,</span>
<span class="sd">        such as statsmodels or seaborn.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        picks : array-like of int | None</span>
<span class="sd">            If None only MEG and EEG channels are kept</span>
<span class="sd">            otherwise the channels indices in picks are kept.</span>
<span class="sd">        index : tuple of str | None</span>
<span class="sd">            Column to be used as index for the data. Valid string options</span>
<span class="sd">            are &#39;epoch&#39;, &#39;time&#39; and &#39;condition&#39;. If None, all three info</span>
<span class="sd">            columns will be included in the table as categorial data.</span>
<span class="sd">        scale_time : float</span>
<span class="sd">            Scaling to be applied to time units.</span>
<span class="sd">        scalings : dict | None</span>
<span class="sd">            Scaling to be applied to the channels picked. If None, defaults to</span>
<span class="sd">            ``scalings=dict(eeg=1e6, grad=1e13, mag=1e15, misc=1.0)``.</span>
<span class="sd">        copy : bool</span>
<span class="sd">            If true, data will be copied. Else data may be modified in place.</span>
<span class="sd">        start : int | None</span>
<span class="sd">            If it is a Raw object, this defines a starting index for creating</span>
<span class="sd">            the dataframe from a slice. The times will be interpolated from the</span>
<span class="sd">            index and the sampling rate of the signal.</span>
<span class="sd">        stop : int | None</span>
<span class="sd">            If it is a Raw object, this defines a stop index for creating</span>
<span class="sd">            the dataframe from a slice. The times will be interpolated from the</span>
<span class="sd">            index and the sampling rate of the signal.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : instance of pandas.core.DataFrame</span>
<span class="sd">            A dataframe suitable for usage with other</span>
<span class="sd">            statistical/plotting/analysis packages. Column/Index values will</span>
<span class="sd">            depend on the object type being converted, but should be</span>
<span class="sd">            human-readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..epochs</span> <span class="k">import</span> <span class="n">BaseEpochs</span>
        <span class="kn">from</span> <span class="nn">..evoked</span> <span class="k">import</span> <span class="n">Evoked</span>
        <span class="kn">from</span> <span class="nn">..source_estimate</span> <span class="k">import</span> <span class="n">_BaseSourceEstimate</span>

        <span class="n">pd</span> <span class="o">=</span> <span class="n">_check_pandas_installed</span><span class="p">()</span>
        <span class="n">mindex</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># Treat SourceEstimates special because they don&#39;t have the same info</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_BaseSourceEstimate</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subject</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">default_index</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">default_index</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">T</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">mindex</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;subject&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subject</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># surface source estimates</span>
                <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="p">[</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;LH&#39;</span> <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;RH&#39;</span><span class="p">,</span> <span class="n">vert</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">vertno</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">vertno</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># volume source estimates</span>
                <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;VOL </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vert</span><span class="p">)</span> <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseEpochs</span><span class="p">,</span> <span class="n">BaseRaw</span><span class="p">,</span> <span class="n">Evoked</span><span class="p">)):</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_check_picks</span><span class="p">(</span><span class="n">picks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BaseEpochs</span><span class="p">):</span>
                <span class="n">default_index</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">,</span> <span class="s1">&#39;epoch&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">()[:,</span> <span class="n">picks</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
                <span class="n">n_epochs</span><span class="p">,</span> <span class="n">n_picks</span><span class="p">,</span> <span class="n">n_times</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># (time*epochs) x signals</span>

                <span class="c1"># Multi-index creation</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">n_epochs</span><span class="p">)</span>
                <span class="n">id_swapped</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">id_swapped</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]]</span>
                <span class="n">mindex</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;condition&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">n_times</span><span class="p">)))</span>
                <span class="n">mindex</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;epoch&#39;</span><span class="p">,</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">),</span> <span class="n">n_times</span><span class="p">)))</span>
                <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseRaw</span><span class="p">,</span> <span class="n">Evoked</span><span class="p">)):</span>
                <span class="n">default_index</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BaseRaw</span><span class="p">):</span>
                    <span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Evoked</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
                    <span class="n">n_picks</span><span class="p">,</span> <span class="n">n_times</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>
                <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">]</span>

            <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">]</span>
            <span class="n">n_channel_types</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ch_types_used</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">scalings</span> <span class="o">=</span> <span class="n">_handle_default</span><span class="p">(</span><span class="s1">&#39;scalings&#39;</span><span class="p">,</span> <span class="n">scalings</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">scalings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                    <span class="n">n_channel_types</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">ch_types_used</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ch_types_used</span><span class="p">:</span>
                <span class="n">scaling</span> <span class="o">=</span> <span class="n">scalings</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">picks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">))</span> <span class="k">if</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scaling</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In case some other object gets this mixin w/o an explicit check</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Object must be one of Raw, Epochs, Evoked,  or &#39;</span> <span class="o">+</span>
                            <span class="s1">&#39;SourceEstimate. This is </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

        <span class="c1"># Make sure that the time index is scaled correctly</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">times</span> <span class="o">*</span> <span class="n">scale_time</span><span class="p">)</span>
        <span class="n">mindex</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">times</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_check_pandas_index_arguments</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">default_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span>

        <span class="k">if</span> <span class="n">copy</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mdx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">mindex</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">mdx</span> <span class="ow">in</span> <span class="n">mindex</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">col_names</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mindex</span><span class="p">):</span>
            <span class="n">df</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Converting time column to int64...&#39;</span><span class="p">)</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">default_index</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">):</span>
            <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;signal&#39;</span>
        <span class="k">return</span> <span class="n">df</span>


<span class="k">class</span> <span class="nc">TimeMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to add sfreq and time_as_index capabilities to certain classes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">time_as_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">use_rounding</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert time to indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : list-like | float | int</span>
<span class="sd">            List of numbers or a number representing points in time.</span>
<span class="sd">        use_rounding : boolean</span>
<span class="sd">            If True, use rounding (instead of truncation) when converting</span>
<span class="sd">            times to indices. This can help avoid non-unique indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : ndarray</span>
<span class="sd">            Indices corresponding to the times supplied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..source_estimate</span> <span class="k">import</span> <span class="n">_BaseSourceEstimate</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_BaseSourceEstimate</span><span class="p">):</span>
            <span class="n">sfreq</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstep</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">sfreq</span>
        <span class="k">if</span> <span class="n">use_rounding</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_fun</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check shapes.&quot;&quot;&quot;</span>
    <span class="n">want_shape</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Return value must be an ndarray&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">want_shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Return data must have shape </span><span class="si">%s</span><span class="s1"> not </span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">want_shape</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">d</span>


<span class="k">class</span> <span class="nc">BaseRaw</span><span class="p">(</span><span class="n">ProjMixin</span><span class="p">,</span> <span class="n">ContainsMixin</span><span class="p">,</span> <span class="n">UpdateChannelsMixin</span><span class="p">,</span>
              <span class="n">SetChannelsMixin</span><span class="p">,</span> <span class="n">InterpolationMixin</span><span class="p">,</span> <span class="n">ToDataFrameMixin</span><span class="p">,</span>
              <span class="n">TimeMixin</span><span class="p">,</span> <span class="n">SizeMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for Raw data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : dict</span>
<span class="sd">        A dict passed from the subclass.</span>
<span class="sd">    preload : bool | str | ndarray</span>
<span class="sd">        Preload data into memory for data manipulation and faster indexing.</span>
<span class="sd">        If True, the data will be preloaded into memory (fast, requires</span>
<span class="sd">        large amount of memory). If preload is a string, preload is the</span>
<span class="sd">        file name of a memory-mapped file which is used to store the data</span>
<span class="sd">        on the hard drive (slower, requires less memory). If preload is an</span>
<span class="sd">        ndarray, the data are taken from that array. If False, data are not</span>
<span class="sd">        read until save.</span>
<span class="sd">    first_samps : iterable</span>
<span class="sd">        Iterable of the first sample number from each raw file. For unsplit raw</span>
<span class="sd">        files this should be a length-one list or tuple.</span>
<span class="sd">    last_samps : iterable | None</span>
<span class="sd">        Iterable of the last sample number from each raw file. For unsplit raw</span>
<span class="sd">        files this should be a length-one list or tuple. If None, then preload</span>
<span class="sd">        must be an ndarray.</span>
<span class="sd">    filenames : tuple</span>
<span class="sd">        Tuple of length one (for unsplit raw files) or length &gt; 1 (for split</span>
<span class="sd">        raw files).</span>
<span class="sd">    raw_extras : list</span>
<span class="sd">        Whatever data is necessary for on-demand reads. For `RawFIF` this means</span>
<span class="sd">        a list of variables formerly known as ``_rawdirs``.</span>
<span class="sd">    orig_format : str</span>
<span class="sd">        The data format of the original raw file (e.g., ``&#39;double&#39;``).</span>
<span class="sd">    dtype : dtype | None</span>
<span class="sd">        The dtype of the raw data. If preload is an ndarray, its dtype must</span>
<span class="sd">        match what is passed here.</span>
<span class="sd">    verbose : bool, str, int, or None</span>
<span class="sd">        If not None, override default verbose level (see :func:`mne.verbose`</span>
<span class="sd">        and :ref:`Logging documentation &lt;tut_logging&gt;` for more).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `BaseRaw` class is public to allow for stable type-checking in user</span>
<span class="sd">    code (i.e., ``isinstance(my_raw_object, BaseRaw)``) but should not be used</span>
<span class="sd">    as a constructor for `Raw` objects (use instead one of the subclass</span>
<span class="sd">    constructors, or one of the ``mne.io.read_raw_*`` functions).</span>

<span class="sd">    Subclasses must provide the following methods:</span>

<span class="sd">        * _read_segment_file(self, data, idx, fi, start, stop, cals, mult)</span>
<span class="sd">          (only needed for types that support on-demand disk reads)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mne.io.Raw : Documentation of attribute and methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">first_samps</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">last_samps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">filenames</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">raw_extras</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span>
                 <span class="n">orig_format</span><span class="o">=</span><span class="s1">&#39;double&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa: D102</span>
        <span class="c1"># wait until the end to preload data, but triage here</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preload</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># some functions (e.g., filtering) only work w/64-bit data</span>
            <span class="k">if</span> <span class="n">preload</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;datatype must be float64 or complex128, &#39;</span>
                                   <span class="s1">&#39;not </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">preload</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">preload</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;preload and dtype must match&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">preload</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_samps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">last_samps</span> <span class="o">=</span> <span class="p">[</span><span class="n">first_samps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">load_from_disk</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">last_samps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;last_samps must be given unless preload is &#39;</span>
                                 <span class="s1">&#39;an ndarray&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">preload</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">load_from_disk</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">preload</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preload</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad preload: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">preload</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">load_from_disk</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">last_samps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">first_samps</span><span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">_check_consistency</span><span class="p">()</span>  <span class="c1"># make sure subclass did a good job</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;buffer_size_sec&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Reader error, notify mne-python developers&#39;</span><span class="p">)</span>
        <span class="n">cals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]):</span>
            <span class="n">cals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;range&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;cal&#39;</span><span class="p">]</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad cals for channels </span><span class="si">%s</span><span class="s1">&#39;</span>
                             <span class="o">%</span> <span class="nb">dict</span><span class="p">((</span><span class="n">ii</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">bad</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cals</span> <span class="o">=</span> <span class="n">cals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_extras</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">raw_extras</span><span class="p">)</span>
        <span class="c1"># deal with compensation (only relevant for CTF data, either CTF</span>
        <span class="c1"># reader or MNE-C converted CTF-&gt;FIF files)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_comp_grade</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compensation_grade</span>  <span class="c1"># read property</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_comp_grade</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Current compensation grade : </span><span class="si">%d</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_comp_grade</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_format</span> <span class="o">=</span> <span class="n">orig_format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_projectors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_projector</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype_</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># If we have True or a string, actually do the preloading</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_times</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">load_from_disk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_preload_data</span><span class="p">(</span><span class="n">preload</span><span class="p">)</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">apply_gradient_compensation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grade</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply CTF gradient compensation.</span>

<span class="sd">        .. warning:: The compensation matrices are stored with single</span>
<span class="sd">                     precision, so repeatedly switching between different</span>
<span class="sd">                     of compensation (e.g., 0-&gt;1-&gt;3-&gt;2) can increase</span>
<span class="sd">                     numerical noise, especially if data are saved to</span>
<span class="sd">                     disk in between changing grades. It is thus best to</span>
<span class="sd">                     only use a single gradient compensation level in</span>
<span class="sd">                     final analyses.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grade : int</span>
<span class="sd">            CTF gradient compensation level.</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        raw : instance of Raw</span>
<span class="sd">            The modified Raw instance. Works in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grade</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">grade</span><span class="p">)</span>
        <span class="n">current_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compensation_grade</span>
        <span class="k">if</span> <span class="n">current_comp</span> <span class="o">!=</span> <span class="n">grade</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot change compensation on data where &#39;</span>
                                   <span class="s1">&#39;projectors have been applied&#39;</span><span class="p">)</span>
            <span class="c1"># Figure out what operator to use (varies depending on preload)</span>
            <span class="n">from_comp</span> <span class="o">=</span> <span class="n">current_comp</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_comp_grade</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="n">make_compensator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">from_comp</span><span class="p">,</span> <span class="n">grade</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Compensator constructed to change </span><span class="si">%d</span><span class="s1"> -&gt; </span><span class="si">%d</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">current_comp</span><span class="p">,</span> <span class="n">grade</span><span class="p">))</span>
            <span class="n">set_current_comp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">grade</span><span class="p">)</span>
            <span class="c1"># We might need to apply it to our data now</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Applying compensator to loaded data&#39;</span><span class="p">)</span>
                <span class="n">lims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">),</span> <span class="mi">10000</span><span class="p">),</span>
                                       <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)]])</span>
                <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lims</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lims</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_comp</span> <span class="o">=</span> <span class="n">comp</span>  <span class="c1"># store it for later use</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Datatype for loading data (property so subclasses can override).&quot;&quot;&quot;</span>
        <span class="c1"># most classes only store real data, they won&#39;t need anything special</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype_</span>

    <span class="k">def</span> <span class="nf">_read_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">projector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a chunk of raw data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, (optional)</span>
<span class="sd">            first sample to include (first is 0). If omitted, defaults to the</span>
<span class="sd">            first sample in data.</span>
<span class="sd">        stop : int, (optional)</span>
<span class="sd">            First sample to not include.</span>
<span class="sd">            If omitted, data is included to the end.</span>
<span class="sd">        sel : array, optional</span>
<span class="sd">            Indices of channels to select.</span>
<span class="sd">        data_buffer : array or str, optional</span>
<span class="sd">            numpy array to fill with data read, must have the correct shape.</span>
<span class="sd">            If str, a np.memmap with the correct data type will be used</span>
<span class="sd">            to store the data.</span>
<span class="sd">        projector : array</span>
<span class="sd">            SSP operator to apply to the data.</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : array, [channels x samples]</span>
<span class="sd">           the data matrix (channels x samples).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Initial checks</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span> <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">min</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">stop</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No data in this range&#39;</span><span class="p">)</span>

        <span class="c1">#  Initialize the data and calibration vector</span>
        <span class="n">n_sel_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">sel</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span>
        <span class="c1"># convert sel to a slice if possible for efficiency</span>
        <span class="k">if</span> <span class="n">sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sel</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">sel</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sel</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_sel_channels</span><span class="p">,</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_buffer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data_buffer</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">data_shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;data_buffer has incorrect shape: </span><span class="si">%s</span><span class="s1"> != </span><span class="si">%s</span><span class="s1">&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">data_buffer</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">data_shape</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data_buffer</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_buffer</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="c1"># use a memmap</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">data_buffer</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                             <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">data_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># deal with having multiple files accessed by the raw object</span>
        <span class="n">cumul_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_lengths</span><span class="p">,</span>
                                                   <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)))</span>
        <span class="n">cumul_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">cumul_lens</span><span class="p">)</span>
        <span class="n">files_used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">cumul_lens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                     <span class="n">cumul_lens</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># set up cals and mult (cals, compensation, and projector)</span>
        <span class="n">cals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cals</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">projector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp</span> <span class="o">*</span> <span class="n">cals</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projector</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">mult</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">cals</span>
        <span class="k">elif</span> <span class="n">projector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="n">projector</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">cals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cals</span> <span class="o">=</span> <span class="n">cals</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># read from necessary files</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">files_used</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">start_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span>
            <span class="c1"># first iteration (only) could start in the middle somewhere</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start_file</span> <span class="o">+=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">cumul_lens</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span>
            <span class="n">stop_file</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">stop</span> <span class="o">-</span> <span class="n">cumul_lens</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">fi</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">start_file</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="ow">or</span> <span class="n">stop_file</span> <span class="o">&lt;</span> <span class="n">start_file</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad array indexing, could be a bug&#39;</span><span class="p">)</span>
            <span class="n">n_read</span> <span class="o">=</span> <span class="n">stop_file</span> <span class="o">-</span> <span class="n">start_file</span>
            <span class="n">this_sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">n_read</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_segment_file</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">this_sl</span><span class="p">],</span> <span class="n">idx</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
                                    <span class="nb">int</span><span class="p">(</span><span class="n">start_file</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">stop_file</span><span class="p">),</span>
                                    <span class="n">cals</span><span class="p">,</span> <span class="n">mult</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">n_read</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_read_segment_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">cals</span><span class="p">,</span> <span class="n">mult</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a segment of data from a file.</span>

<span class="sd">        Only needs to be implemented for readers that support</span>
<span class="sd">        ``preload=False``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : ndarray, shape (len(idx), stop - start + 1)</span>
<span class="sd">            The data array. Should be modified inplace.</span>
<span class="sd">        idx : ndarray | slice</span>
<span class="sd">            The requested channel indices.</span>
<span class="sd">        fi : int</span>
<span class="sd">            The file index that must be read from.</span>
<span class="sd">        start : int</span>
<span class="sd">            The start sample in the given file.</span>
<span class="sd">        stop : int</span>
<span class="sd">            The stop sample in the given file (inclusive).</span>
<span class="sd">        cals : ndarray, shape (len(idx), 1)</span>
<span class="sd">            Channel calibrations (already sub-indexed).</span>
<span class="sd">        mult : ndarray, shape (len(idx), len(info[&#39;chs&#39;]) | None</span>
<span class="sd">            The compensation + projection + cals matrix, if applicable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_check_bad_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span>
                           <span class="n">reject_by_annotation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if data segment is bad.</span>

<span class="sd">        If the slice is good, returns the data in desired range.</span>
<span class="sd">        If rejected based on annotation, returns description of the</span>
<span class="sd">        bad segment as a string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int</span>
<span class="sd">            First sample of the slice.</span>
<span class="sd">        stop : int</span>
<span class="sd">            End of the slice.</span>
<span class="sd">        picks : array of int</span>
<span class="sd">            Channel picks.</span>
<span class="sd">        reject_by_annotation : bool</span>
<span class="sd">            Whether to perform rejection based on annotations.</span>
<span class="sd">            False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : array | str</span>
<span class="sd">            Data in the desired range (good segment) or description of the bad</span>
<span class="sd">            segment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">reject_by_annotation</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">annot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span>
            <span class="n">sfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>
            <span class="n">onset</span> <span class="o">=</span> <span class="n">_sync_onset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annot</span><span class="o">.</span><span class="n">onset</span><span class="p">)</span>
            <span class="n">overlaps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">onset</span> <span class="o">&lt;</span> <span class="n">stop</span> <span class="o">/</span> <span class="n">sfreq</span><span class="p">)</span>
            <span class="n">overlaps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">onset</span><span class="p">[</span><span class="n">overlaps</span><span class="p">]</span> <span class="o">+</span> <span class="n">annot</span><span class="o">.</span><span class="n">duration</span><span class="p">[</span><span class="n">overlaps</span><span class="p">]</span> <span class="o">&gt;</span>
                                <span class="n">start</span> <span class="o">/</span> <span class="n">sfreq</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">descr</span> <span class="ow">in</span> <span class="n">annot</span><span class="o">.</span><span class="n">description</span><span class="p">[</span><span class="n">overlaps</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">descr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;bad&#39;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">descr</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load raw data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        raw : instance of Raw</span>
<span class="sd">            The raw object with data.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function will load raw data if it was not already preloaded.</span>
<span class="sd">        If data were already preloaded, it will do nothing.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_preload_data</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">_preload_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preload</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Actually preload the data.&quot;&quot;&quot;</span>
        <span class="n">data_buffer</span> <span class="o">=</span> <span class="n">preload</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preload</span><span class="p">,</span> <span class="p">(</span><span class="n">string_types</span><span class="p">,</span>
                                                      <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reading </span><span class="si">%d</span><span class="s1"> ... </span><span class="si">%d</span><span class="s1">  =  </span><span class="si">%9.3f</span><span class="s1"> ... </span><span class="si">%9.3f</span><span class="s1"> secs...&#39;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_segment</span><span class="p">(</span><span class="n">data_buffer</span><span class="o">=</span><span class="n">data_buffer</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># no longer needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_update_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update times.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_times</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>
        <span class="c1"># make it immutable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_first_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_samp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The first data sample.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">last_samp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The last data sample.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_lengths</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_raw_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: D401</span>
        <span class="sd">&quot;&quot;&quot;Annotations for marking segments of data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filenames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The filenames used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span><span class="p">)</span>

    <span class="nd">@annotations</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotations</span><span class="p">,</span> <span class="n">emit_warning</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for annotations.</span>

<span class="sd">        This setter checks if they are inside the data range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        annotations : Instance of mne.Annotations</span>
<span class="sd">            Annotations to set.</span>
<span class="sd">        emit_warning : bool</span>
<span class="sd">            Whether to emit warnings when limiting or omitting annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">annotations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">Annotations</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Annotations must be an instance of &#39;</span>
                                 <span class="s1">&#39;mne.Annotations. Got </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">annotations</span><span class="p">)</span>
            <span class="n">meas_date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_date&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">meas_date</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">meas_date</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">meas_date</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas_date</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">meas_date</span> <span class="o">=</span> <span class="n">meas_date</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">meas_date</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1000000.</span>
            <span class="k">if</span> <span class="n">annotations</span><span class="o">.</span><span class="n">orig_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">annotations</span><span class="o">.</span><span class="n">orig_time</span> <span class="o">-</span> <span class="n">meas_date</span> <span class="o">-</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">omit_ind</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">omitted</span> <span class="o">=</span> <span class="n">limited</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">onset</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">annotations</span><span class="o">.</span><span class="n">onset</span><span class="p">):</span>
                <span class="n">onset</span> <span class="o">+=</span> <span class="n">offset</span>
                <span class="k">if</span> <span class="n">onset</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">omitted</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">omit_ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">onset</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">onset</span> <span class="o">+</span> <span class="n">annotations</span><span class="o">.</span><span class="n">duration</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">omitted</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">omit_ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">limited</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">duration</span> <span class="o">=</span> <span class="n">annotations</span><span class="o">.</span><span class="n">duration</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+</span> <span class="n">onset</span>
                        <span class="n">annotations</span><span class="o">.</span><span class="n">duration</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">duration</span>
                        <span class="n">annotations</span><span class="o">.</span><span class="n">onset</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span>
                <span class="k">elif</span> <span class="n">onset</span> <span class="o">+</span> <span class="n">annotations</span><span class="o">.</span><span class="n">duration</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">limited</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">annotations</span><span class="o">.</span><span class="n">duration</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">onset</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">onset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">annotations</span><span class="o">.</span><span class="n">onset</span><span class="p">,</span> <span class="n">omit_ind</span><span class="p">)</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">annotations</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span> <span class="n">omit_ind</span><span class="p">)</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">annotations</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                                                <span class="n">omit_ind</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">emit_warning</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">omitted</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Omitted </span><span class="si">%s</span><span class="s1"> annotation(s) that were outside data &#39;</span>
                         <span class="s1">&#39;range.&#39;</span> <span class="o">%</span> <span class="n">omitted</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">limited</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Limited </span><span class="si">%s</span><span class="s1"> annotation(s) that were expanding &#39;</span>
                         <span class="s1">&#39;outside the data range.&#39;</span> <span class="o">%</span> <span class="n">limited</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="n">annotations</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: D105</span>
        <span class="c1"># remove file for memmap</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_data&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s1">&#39;filename&#39;</span><span class="p">):</span>
            <span class="c1"># First, close the file out; happens automatically on del</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">filename</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
            <span class="c1"># Now file can be removed</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># ignore file that no longer exists</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Entering with block.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception_type</span><span class="p">,</span> <span class="n">exception_val</span><span class="p">,</span> <span class="n">trace</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Exit with block.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exception_type</span><span class="p">,</span> <span class="n">exception_val</span><span class="p">,</span> <span class="n">trace</span>

    <span class="k">def</span> <span class="nf">_parse_get_set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the __getitem__ / __setitem__ tuples.&quot;&quot;&quot;</span>
        <span class="c1"># make sure item is a tuple</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># only channel selection passed</span>
            <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># should be channels and time instants</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unable to access raw data (need both channels &quot;</span>
                               <span class="s2">&quot;and time)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span> <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">nchan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="n">nchan</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;start must be &gt;= -</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">nchan</span><span class="p">)</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nchan</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">step</span> <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">time_slice</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_slice</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">time_slice</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span>
                                 <span class="n">time_slice</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">item1</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Let&#39;s do automated type conversion to integer here</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                <span class="n">item1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">item1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">item1</span><span class="p">,</span> <span class="n">item1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must pass int or slice to __getitem__&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;step needs to be 1 : </span><span class="si">%d</span><span class="s1"> given&#39;</span> <span class="o">%</span> <span class="n">step</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sel</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty channel list&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sel</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get raw data and times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : tuple or array-like</span>
<span class="sd">            See below for use cases.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : ndarray, shape (n_channels, n_times)</span>
<span class="sd">            The raw data.</span>
<span class="sd">        times : ndarray, shape (n_times,)</span>
<span class="sd">            The times associated with the data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Generally raw data is accessed as::</span>

<span class="sd">            &gt;&gt;&gt; data, times = raw[picks, time_slice]  # doctest: +SKIP</span>

<span class="sd">        To get all data, you can thus do either of::</span>

<span class="sd">            &gt;&gt;&gt; data, times = raw[:]  # doctest: +SKIP</span>

<span class="sd">        Which will be equivalent to:</span>

<span class="sd">            &gt;&gt;&gt; data, times = raw[:, :]  # doctest: +SKIP</span>

<span class="sd">        To get only the good MEG data from 10-20 seconds, you could do::</span>

<span class="sd">            &gt;&gt;&gt; picks = mne.pick_types(raw.info, meg=True, exclude=&#39;bads&#39;)  # doctest: +SKIP</span>
<span class="sd">            &gt;&gt;&gt; t_idx = raw.time_as_index([10., 20.])  # doctest: +SKIP</span>
<span class="sd">            &gt;&gt;&gt; data, times = raw[picks, t_idx[0]:t_idx[1]]  # doctest: +SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
        <span class="n">sel</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_get_set_params</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_segment</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">sel</span><span class="o">=</span><span class="n">sel</span><span class="p">,</span>
                                      <span class="n">projector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_projector</span><span class="p">,</span>
                                      <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">times</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set raw data content.&quot;&quot;&quot;</span>
        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Modifying data of Raw&#39;</span><span class="p">)</span>
        <span class="n">sel</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_get_set_params</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="c1"># set the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reject_by_annotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_times</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get data in the given range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        picks : array-like of int | None</span>
<span class="sd">            Indices of channels to get data from. If None, data from all</span>
<span class="sd">            channels is returned</span>
<span class="sd">        start : int</span>
<span class="sd">            The first sample to include. Defaults to 0.</span>
<span class="sd">        stop : int | None</span>
<span class="sd">            End sample (first not to include). If None (default), the end of</span>
<span class="sd">            the data is  used.</span>
<span class="sd">        reject_by_annotation : None | &#39;omit&#39; | &#39;NaN&#39;</span>
<span class="sd">            Whether to reject by annotation. If None (default), no rejection is</span>
<span class="sd">            done. If &#39;omit&#39;, segments annotated with description starting with</span>
<span class="sd">            &#39;bad&#39; are omitted. If &#39;NaN&#39;, the bad samples are filled with NaNs.</span>
<span class="sd">        return_times : bool</span>
<span class="sd">            Whether to return times as well. Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : ndarray, shape (n_channels, n_times)</span>
<span class="sd">            Copy of the data in the given range.</span>
<span class="sd">        times : ndarray, shape (n_times,)</span>
<span class="sd">            Times associated with the data samples. Only returned if</span>
<span class="sd">            return_times=True.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.14.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">])</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span> <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">stop</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">reject_by_annotation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">return_times</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">times</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">if</span> <span class="n">reject_by_annotation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;omit&#39;</span><span class="p">,</span> <span class="s1">&#39;nan&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;reject_by_annotation must be None, &#39;omit&#39; or &quot;</span>
                             <span class="s2">&quot;&#39;NaN&#39;. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">reject_by_annotation</span><span class="p">)</span>
        <span class="n">sfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>
        <span class="n">bads</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">desc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">desc</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;BAD&#39;</span><span class="p">)]</span>
        <span class="n">onsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">onset</span><span class="p">[</span><span class="n">bads</span><span class="p">]</span>
        <span class="n">onsets</span> <span class="o">=</span> <span class="n">_sync_onset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onsets</span><span class="p">)</span>
        <span class="n">ends</span> <span class="o">=</span> <span class="n">onsets</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">duration</span><span class="p">[</span><span class="n">bads</span><span class="p">]</span>
        <span class="n">omit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">onsets</span> <span class="o">&gt;</span> <span class="n">stop</span> <span class="o">/</span> <span class="n">sfreq</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ends</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">/</span> <span class="n">sfreq</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">onsets</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">omit</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ends</span><span class="p">,</span> <span class="n">omit</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">return_times</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">times</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span>
        <span class="n">onsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_as_index</span><span class="p">(</span><span class="n">onsets</span><span class="p">[</span><span class="n">order</span><span class="p">])</span>
        <span class="n">ends</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_as_index</span><span class="p">(</span><span class="n">ends</span><span class="p">[</span><span class="n">order</span><span class="p">])</span>

        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">onsets</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">ends</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">ends</span><span class="p">)</span>
        <span class="n">used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">onset</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">ends</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">onset</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">used</span><span class="p">[</span><span class="n">onset</span> <span class="o">-</span> <span class="n">start</span><span class="p">:</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="kc">False</span><span class="p">],</span> <span class="n">used</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span><span class="p">]])</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">used</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">used</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">start</span>
        <span class="n">stops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">used</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">used</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">start</span>
        <span class="k">if</span> <span class="n">reject_by_annotation</span> <span class="o">==</span> <span class="s1">&#39;omit&#39;</span><span class="p">:</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">),</span> <span class="p">(</span><span class="n">stops</span> <span class="o">-</span> <span class="n">starts</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">stops</span><span class="p">):</span>  <span class="c1"># get the data</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[:,</span> <span class="o">~</span><span class="n">used</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">return_times</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">times</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">apply_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a function to a subset of channels.</span>

<span class="sd">        The function &quot;fun&quot; is applied to the channels defined in &quot;picks&quot;. The</span>
<span class="sd">        data of the Raw object is modified inplace. If the function returns</span>
<span class="sd">        a different data type (e.g. numpy.complex) it must be specified using</span>
<span class="sd">        the dtype parameter, which causes the data type used for representing</span>
<span class="sd">        the raw data to change.</span>

<span class="sd">        The Raw object has to have the data loaded e.g. with ``preload=True``</span>
<span class="sd">        or ``self.load_data()``.</span>

<span class="sd">        .. note:: If n_jobs &gt; 1, more memory is required as</span>
<span class="sd">                  ``len(picks) * n_times`` additional time points need to</span>
<span class="sd">                  be temporaily stored in memory.</span>

<span class="sd">        .. note:: If the data type changes (dtype != None), more memory is</span>
<span class="sd">                  required since the original and the converted data needs</span>
<span class="sd">                  to be stored in memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fun : function</span>
<span class="sd">            A function to be applied to the channels. The first argument of</span>
<span class="sd">            fun has to be a timeseries (numpy.ndarray). The function must</span>
<span class="sd">            return an numpy.ndarray with the same size as the input.</span>
<span class="sd">        picks : array-like of int (default: None)</span>
<span class="sd">            Indices of channels to apply the function to. If None, all data</span>
<span class="sd">            channels are used.</span>
<span class="sd">        dtype : numpy.dtype (default: None)</span>
<span class="sd">            Data type to use for raw data after applying the function. If None</span>
<span class="sd">            the data type is not modified.</span>
<span class="sd">        n_jobs: int (default: 1)</span>
<span class="sd">            Number of jobs to run in parallel.</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments to pass to fun (first pos. argument</span>
<span class="sd">            of fun is the timeseries of a channel).</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments to pass to fun. Note that if &quot;verbose&quot; is passed</span>
<span class="sd">            as a member of ``kwargs``, it will be consumed and will override</span>
<span class="sd">            the default mne-python verbose level (see :func:`mne.verbose` and</span>
<span class="sd">            :ref:`Logging documentation &lt;tut_logging&gt;` for more).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : instance of Raw</span>
<span class="sd">            The raw object with transformed data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;raw.apply_function&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">_pick_data_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[],</span>
                                        <span class="n">with_ref_meg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fun needs to be a function&#39;</span><span class="p">)</span>

        <span class="n">data_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># modify data inplace to save memory</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_check_fun</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">data_in</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:],</span>
                                                <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use parallel function</span>
            <span class="n">parallel</span><span class="p">,</span> <span class="n">p_fun</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">parallel_func</span><span class="p">(</span><span class="n">_check_fun</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">data_picks_new</span> <span class="o">=</span> <span class="n">parallel</span><span class="p">(</span><span class="n">p_fun</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">data_in</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                      <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pp</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">picks</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data_picks_new</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">apply_hilbert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">envelope</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute analytic signal or envelope for a subset of channels.</span>

<span class="sd">        If envelope=False, the analytic signal for the channels defined in</span>
<span class="sd">        &quot;picks&quot; is computed and the data of the Raw object is converted to</span>
<span class="sd">        a complex representation (the analytic signal is complex valued).</span>

<span class="sd">        If envelope=True, the absolute value of the analytic signal for the</span>
<span class="sd">        channels defined in &quot;picks&quot; is computed, resulting in the envelope</span>
<span class="sd">        signal.</span>

<span class="sd">        .. warning: Do not use ``envelope=True`` if you intend to compute</span>
<span class="sd">                    an inverse solution from the raw data. If you want to</span>
<span class="sd">                    compute the envelope in source space, use</span>
<span class="sd">                    ``envelope=False`` and compute the envelope after the</span>
<span class="sd">                    inverse solution has been obtained.</span>

<span class="sd">        .. note:: If envelope=False, more memory is required since the</span>
<span class="sd">                  original raw data as well as the analytic signal have</span>
<span class="sd">                  temporarily to be stored in memory.</span>

<span class="sd">        .. note:: If n_jobs &gt; 1, more memory is required as</span>
<span class="sd">                  ``len(picks) * n_times`` additional time points need to</span>
<span class="sd">                  be temporaily stored in memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        picks : array-like of int (default: None)</span>
<span class="sd">            Indices of channels to apply the function to. If None, all data</span>
<span class="sd">            channels are used.</span>
<span class="sd">        envelope : bool (default: False)</span>
<span class="sd">            Compute the envelope signal of each channel.</span>
<span class="sd">        n_jobs: int</span>
<span class="sd">            Number of jobs to run in parallel.</span>
<span class="sd">        n_fft : int | None | str</span>
<span class="sd">            Points to use in the FFT for Hilbert transformation. The signal</span>
<span class="sd">            will be padded with zeros before computing Hilbert, then cut back</span>
<span class="sd">            to original length. If None, n == self.n_times. If &#39;auto&#39;,</span>
<span class="sd">            the next highest fast FFT length will be use.</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more). Defaults to self.verbose.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : instance of Raw</span>
<span class="sd">            The raw object with transformed data.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The analytic signal &quot;x_a(t)&quot; of &quot;x(t)&quot; is::</span>

<span class="sd">            x_a = F^{-1}(F(x) 2U) = x + i y</span>

<span class="sd">        where &quot;F&quot; is the Fourier transform, &quot;U&quot; the unit step function,</span>
<span class="sd">        and &quot;y&quot; the Hilbert transform of &quot;x&quot;. One usage of the analytic</span>
<span class="sd">        signal is the computation of the envelope signal, which is given by</span>
<span class="sd">        &quot;e(t) = abs(x_a(t))&quot;. Due to the linearity of Hilbert transform and the</span>
<span class="sd">        MNE inverse solution, the enevlope in source space can be obtained</span>
<span class="sd">        by computing the analytic signal in sensor space, applying the MNE</span>
<span class="sd">        inverse, and computing the envelope in source space.</span>

<span class="sd">        Also note that the n_fft parameter will allow you to pad the signal</span>
<span class="sd">        with zeros before performing the Hilbert transform. This padding</span>
<span class="sd">        is cut off, but it may result in a slightly different result</span>
<span class="sd">        (particularly around the edges). Use at your own risk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_fft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_fft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n_fft</span> <span class="o">!=</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n_fft must be an integer, string, or None, &#39;</span>
                                 <span class="s1">&#39;got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n_fft</span><span class="p">),))</span>
            <span class="n">n_fft</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">))</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_fft</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n_fft must be greater than n_times&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">envelope</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_function</span><span class="p">(</span><span class="n">_my_hilbert</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span>
                                   <span class="n">envelope</span><span class="o">=</span><span class="n">envelope</span><span class="p">)</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l_freq</span><span class="p">,</span> <span class="n">h_freq</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_length</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
               <span class="n">l_trans_bandwidth</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">h_trans_bandwidth</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
               <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">iir_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span>
               <span class="n">fir_window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="n">fir_design</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter a subset of channels.</span>

<span class="sd">        Applies a zero-phase low-pass, high-pass, band-pass, or band-stop</span>
<span class="sd">        filter to the channels selected by ``picks``. By default the data</span>
<span class="sd">        of the Raw object is modified inplace.</span>

<span class="sd">        The Raw object has to have the data loaded e.g. with ``preload=True``</span>
<span class="sd">        or ``self.load_data()``.</span>

<span class="sd">        ``l_freq`` and ``h_freq`` are the frequencies below which and above</span>
<span class="sd">        which, respectively, to filter out of the data. Thus the uses are:</span>

<span class="sd">            * ``l_freq &lt; h_freq``: band-pass filter</span>
<span class="sd">            * ``l_freq &gt; h_freq``: band-stop filter</span>
<span class="sd">            * ``l_freq is not None and h_freq is None``: high-pass filter</span>
<span class="sd">            * ``l_freq is None and h_freq is not None``: low-pass filter</span>

<span class="sd">        ``self.info[&#39;lowpass&#39;]`` and ``self.info[&#39;highpass&#39;]`` are only</span>
<span class="sd">        updated with picks=None.</span>

<span class="sd">        .. note:: If n_jobs &gt; 1, more memory is required as</span>
<span class="sd">                  ``len(picks) * n_times`` additional time points need to</span>
<span class="sd">                  be temporaily stored in memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        l_freq : float | None</span>
<span class="sd">            Low cut-off frequency in Hz. If None the data are only low-passed.</span>
<span class="sd">        h_freq : float | None</span>
<span class="sd">            High cut-off frequency in Hz. If None the data are only</span>
<span class="sd">            high-passed.</span>
<span class="sd">        picks : array-like of int | None</span>
<span class="sd">            Indices of channels to filter. If None only the data (MEG/EEG)</span>
<span class="sd">            channels will be filtered.</span>
<span class="sd">        filter_length : str | int</span>
<span class="sd">            Length of the FIR filter to use (if applicable):</span>

<span class="sd">            * &#39;auto&#39; (default): the filter length is chosen based</span>
<span class="sd">              on the size of the transition regions (6.6 times the reciprocal</span>
<span class="sd">              of the shortest transition band for fir_window=&#39;hamming&#39;</span>
<span class="sd">              and fir_design=&quot;firwin2&quot;, and half that for &quot;firwin&quot;).</span>
<span class="sd">            * str: a human-readable time in</span>
<span class="sd">              units of &quot;s&quot; or &quot;ms&quot; (e.g., &quot;10s&quot; or &quot;5500ms&quot;) will be</span>
<span class="sd">              converted to that number of samples if ``phase=&quot;zero&quot;``, or</span>
<span class="sd">              the shortest power-of-two length at least that duration for</span>
<span class="sd">              ``phase=&quot;zero-double&quot;``.</span>
<span class="sd">            * int: specified length in samples. For fir_design=&quot;firwin&quot;,</span>
<span class="sd">              this should not be used.</span>

<span class="sd">        l_trans_bandwidth : float | str</span>
<span class="sd">            Width of the transition band at the low cut-off frequency in Hz</span>
<span class="sd">            (high pass or cutoff 1 in bandpass). Can be &quot;auto&quot;</span>
<span class="sd">            (default) to use a multiple of ``l_freq``::</span>

<span class="sd">                min(max(l_freq * 0.25, 2), l_freq)</span>

<span class="sd">            Only used for ``method=&#39;fir&#39;``.</span>
<span class="sd">        h_trans_bandwidth : float | str</span>
<span class="sd">            Width of the transition band at the high cut-off frequency in Hz</span>
<span class="sd">            (low pass or cutoff 2 in bandpass). Can be &quot;auto&quot;</span>
<span class="sd">            (default) to use a multiple of ``h_freq``::</span>

<span class="sd">                min(max(h_freq * 0.25, 2.), info[&#39;sfreq&#39;] / 2. - h_freq)</span>

<span class="sd">            Only used for ``method=&#39;fir&#39;``.</span>
<span class="sd">        n_jobs : int | str</span>
<span class="sd">            Number of jobs to run in parallel. Can be &#39;cuda&#39; if scikits.cuda</span>
<span class="sd">            is installed properly, CUDA is initialized, and method=&#39;fir&#39;.</span>
<span class="sd">        method : str</span>
<span class="sd">            &#39;fir&#39; will use overlap-add FIR filtering, &#39;iir&#39; will use IIR</span>
<span class="sd">            forward-backward filtering (via filtfilt).</span>
<span class="sd">        iir_params : dict | None</span>
<span class="sd">            Dictionary of parameters to use for IIR filtering.</span>
<span class="sd">            See mne.filter.construct_iir_filter for details. If iir_params</span>
<span class="sd">            is None and method=&quot;iir&quot;, 4th order Butterworth will be used.</span>
<span class="sd">        phase : str</span>
<span class="sd">            Phase of the filter, only used if ``method=&#39;fir&#39;``.</span>
<span class="sd">            By default, a symmetric linear-phase FIR filter is constructed.</span>
<span class="sd">            If ``phase=&#39;zero&#39;`` (default), the delay of this filter</span>
<span class="sd">            is compensated for. If ``phase==&#39;zero-double&#39;``, then this filter</span>
<span class="sd">            is applied twice, once forward, and once backward. If &#39;minimum&#39;,</span>
<span class="sd">            then a minimum-phase, causal filter will be used.</span>

<span class="sd">            .. versionadded:: 0.13</span>
<span class="sd">        fir_window : str</span>
<span class="sd">            The window to use in FIR design, can be &quot;hamming&quot; (default),</span>
<span class="sd">            &quot;hann&quot; (default in 0.13), or &quot;blackman&quot;.</span>

<span class="sd">            .. versionadded:: 0.13</span>
<span class="sd">        fir_design : str</span>
<span class="sd">            Can be &quot;firwin&quot; (default in 0.16) to use</span>
<span class="sd">            :func:`scipy.signal.firwin`, or &quot;firwin2&quot; (default in 0.15 and</span>
<span class="sd">            before) to use :func:`scipy.signal.firwin2`. &quot;firwin&quot; uses a</span>
<span class="sd">            time-domain design technique that generally gives improved</span>
<span class="sd">            attenuation using fewer samples than &quot;firwin2&quot;.</span>

<span class="sd">            ..versionadded:: 0.15</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more). Defaults to self.verbose.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        raw : instance of Raw</span>
<span class="sd">            The raw instance with filtered data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mne.Epochs.savgol_filter</span>
<span class="sd">        mne.io.Raw.notch_filter</span>
<span class="sd">        mne.io.Raw.resample</span>
<span class="sd">        mne.filter.filter_data</span>
<span class="sd">        mne.filter.construct_iir_filter</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For more information, see the tutorials :ref:`tut_background_filtering`</span>
<span class="sd">        and :ref:`tut_artifacts_filter`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;raw.filter&#39;</span><span class="p">)</span>
        <span class="n">data_picks</span> <span class="o">=</span> <span class="n">_pick_data_or_ica</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
        <span class="n">update_info</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">data_picks</span>
            <span class="n">update_info</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># let&#39;s be safe.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Could not find any valid channels for &#39;</span>
                                   <span class="s1">&#39;your Raw object. Please contact the &#39;</span>
                                   <span class="s1">&#39;MNE-Python developers.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">h_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">l_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">data_picks</span><span class="p">,</span> <span class="n">picks</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">update_info</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Filtering a subset of channels. The highpass and &#39;</span>
                            <span class="s1">&#39;lowpass values in the measurement info will not &#39;</span>
                            <span class="s1">&#39;be updated.&#39;</span><span class="p">)</span>
        <span class="n">filter_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">],</span> <span class="n">l_freq</span><span class="p">,</span> <span class="n">h_freq</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span>
                    <span class="n">filter_length</span><span class="p">,</span> <span class="n">l_trans_bandwidth</span><span class="p">,</span> <span class="n">h_trans_bandwidth</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">iir_params</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="n">phase</span><span class="p">,</span>
                    <span class="n">fir_window</span><span class="o">=</span><span class="n">fir_window</span><span class="p">,</span> <span class="n">fir_design</span><span class="o">=</span><span class="n">fir_design</span><span class="p">)</span>
        <span class="c1"># update info if filter is applied to all data channels,</span>
        <span class="c1"># and it&#39;s not a band-stop filter</span>
        <span class="k">if</span> <span class="n">update_info</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">l_freq</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">l_freq</span> <span class="o">&lt;</span> <span class="n">h_freq</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;lowpass&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                     <span class="n">h_freq</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;lowpass&#39;</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;lowpass&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">h_freq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">h_freq</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">l_freq</span> <span class="o">&lt;</span> <span class="n">h_freq</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;highpass&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                     <span class="n">l_freq</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;highpass&#39;</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;highpass&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">l_freq</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">notch_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_length</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                     <span class="n">notch_widths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trans_bandwidth</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">,</span> <span class="n">iir_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mt_bandwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">p_value</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="n">fir_window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">,</span>
                     <span class="n">fir_design</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Notch filter a subset of channels.</span>

<span class="sd">        Applies a zero-phase notch filter to the channels selected by</span>
<span class="sd">        &quot;picks&quot;. By default the data of the Raw object is modified inplace.</span>

<span class="sd">        The Raw object has to have the data loaded e.g. with ``preload=True``</span>
<span class="sd">        or ``self.load_data()``.</span>

<span class="sd">        .. note:: If n_jobs &gt; 1, more memory is required as</span>
<span class="sd">                  ``len(picks) * n_times`` additional time points need to</span>
<span class="sd">                  be temporaily stored in memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freqs : float | array of float | None</span>
<span class="sd">            Specific frequencies to filter out from data, e.g.,</span>
<span class="sd">            np.arange(60, 241, 60) in the US or np.arange(50, 251, 50) in</span>
<span class="sd">            Europe. None can only be used with the mode &#39;spectrum_fit&#39;,</span>
<span class="sd">            where an F test is used to find sinusoidal components.</span>
<span class="sd">        picks : array-like of int | None</span>
<span class="sd">            Indices of channels to filter. If None only the data (MEG/EEG)</span>
<span class="sd">            channels will be filtered.</span>
<span class="sd">        filter_length : str | int</span>
<span class="sd">            Length of the FIR filter to use (if applicable):</span>

<span class="sd">                * int: specified length in samples.</span>
<span class="sd">                * &#39;auto&#39; (default): the filter length is chosen based</span>
<span class="sd">                  on the size of the transition regions (6.6 times the</span>
<span class="sd">                  reciprocal of the shortest transition band for</span>
<span class="sd">                  fir_window=&#39;hamming&#39;).</span>
<span class="sd">                * str: a human-readable time in</span>
<span class="sd">                  units of &quot;s&quot; or &quot;ms&quot; (e.g., &quot;10s&quot; or &quot;5500ms&quot;) will be</span>
<span class="sd">                  converted to that number of samples if ``phase=&quot;zero&quot;``, or</span>
<span class="sd">                  the shortest power-of-two length at least that duration for</span>
<span class="sd">                  ``phase=&quot;zero-double&quot;``.</span>

<span class="sd">        notch_widths : float | array of float | None</span>
<span class="sd">            Width of each stop band (centred at each freq in freqs) in Hz.</span>
<span class="sd">            If None, freqs / 200 is used.</span>
<span class="sd">        trans_bandwidth : float</span>
<span class="sd">            Width of the transition band in Hz.</span>
<span class="sd">            Only used for ``method=&#39;fir&#39;``.</span>
<span class="sd">        n_jobs : int | str</span>
<span class="sd">            Number of jobs to run in parallel. Can be &#39;cuda&#39; if scikits.cuda</span>
<span class="sd">            is installed properly, CUDA is initialized, and method=&#39;fir&#39;.</span>
<span class="sd">        method : str</span>
<span class="sd">            &#39;fir&#39; will use overlap-add FIR filtering, &#39;iir&#39; will use IIR</span>
<span class="sd">            forward-backward filtering (via filtfilt). &#39;spectrum_fit&#39; will</span>
<span class="sd">            use multi-taper estimation of sinusoidal components.</span>
<span class="sd">        iir_params : dict | None</span>
<span class="sd">            Dictionary of parameters to use for IIR filtering.</span>
<span class="sd">            See mne.filter.construct_iir_filter for details. If iir_params</span>
<span class="sd">            is None and method=&quot;iir&quot;, 4th order Butterworth will be used.</span>
<span class="sd">        mt_bandwidth : float | None</span>
<span class="sd">            The bandwidth of the multitaper windowing function in Hz.</span>
<span class="sd">            Only used in &#39;spectrum_fit&#39; mode.</span>
<span class="sd">        p_value : float</span>
<span class="sd">            p-value to use in F-test thresholding to determine significant</span>
<span class="sd">            sinusoidal components to remove when method=&#39;spectrum_fit&#39; and</span>
<span class="sd">            freqs=None. Note that this will be Bonferroni corrected for the</span>
<span class="sd">            number of frequencies, so large p-values may be justified.</span>
<span class="sd">        phase : str</span>
<span class="sd">            Phase of the filter, only used if ``method=&#39;fir&#39;``.</span>
<span class="sd">            By default, a symmetric linear-phase FIR filter is constructed.</span>
<span class="sd">            If ``phase=&#39;zero&#39;`` (default), the delay of this filter</span>
<span class="sd">            is compensated for. If ``phase==&#39;zero-double&#39;``, then this filter</span>
<span class="sd">            is applied twice, once forward, and once backward. If &#39;minimum&#39;,</span>
<span class="sd">            then a minimum-phase, causal filter will be used.</span>

<span class="sd">            .. versionadded:: 0.13</span>
<span class="sd">        fir_window : str</span>
<span class="sd">            The window to use in FIR design, can be &quot;hamming&quot; (default),</span>
<span class="sd">            &quot;hann&quot;, or &quot;blackman&quot;.</span>

<span class="sd">            .. versionadded:: 0.13</span>
<span class="sd">        fir_design : str</span>
<span class="sd">            Can be &quot;firwin&quot; (default in 0.16) to use</span>
<span class="sd">            :func:`scipy.signal.firwin`, or &quot;firwin2&quot; (default in 0.15 and</span>
<span class="sd">            before) to use :func:`scipy.signal.firwin2`. &quot;firwin&quot; uses a</span>
<span class="sd">            time-domain design technique that generally gives improved</span>
<span class="sd">            attenuation using fewer samples than &quot;firwin2&quot;.</span>

<span class="sd">            ..versionadded:: 0.15</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more). Defaults to self.verbose.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        raw : instance of Raw</span>
<span class="sd">            The raw instance with filtered data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mne.io.Raw.filter</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For details, see :func:`mne.filter.notch_filter`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">_pick_data_or_ica</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
            <span class="c1"># let&#39;s be safe.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Could not find any valid channels for &#39;</span>
                                   <span class="s1">&#39;your Raw object. Please contact the &#39;</span>
                                   <span class="s1">&#39;MNE-Python developers.&#39;</span><span class="p">)</span>
        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;raw.notch_filter&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">notch_filter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">filter_length</span><span class="o">=</span><span class="n">filter_length</span><span class="p">,</span>
            <span class="n">notch_widths</span><span class="o">=</span><span class="n">notch_widths</span><span class="p">,</span> <span class="n">trans_bandwidth</span><span class="o">=</span><span class="n">trans_bandwidth</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">iir_params</span><span class="o">=</span><span class="n">iir_params</span><span class="p">,</span> <span class="n">mt_bandwidth</span><span class="o">=</span><span class="n">mt_bandwidth</span><span class="p">,</span>
            <span class="n">p_value</span><span class="o">=</span><span class="n">p_value</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="n">picks</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">phase</span><span class="o">=</span><span class="n">phase</span><span class="p">,</span> <span class="n">fir_window</span><span class="o">=</span><span class="n">fir_window</span><span class="p">,</span> <span class="n">fir_design</span><span class="o">=</span><span class="n">fir_design</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">npad</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;boxcar&#39;</span><span class="p">,</span> <span class="n">stim_picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample all channels.</span>

<span class="sd">        The Raw object has to have the data loaded e.g. with ``preload=True``</span>
<span class="sd">        or ``self.load_data()``.</span>

<span class="sd">        .. warning:: The intended purpose of this function is primarily to</span>
<span class="sd">                     speed up computations (e.g., projection calculation) when</span>
<span class="sd">                     precise timing of events is not required, as downsampling</span>
<span class="sd">                     raw data effectively jitters trigger timings. It is</span>
<span class="sd">                     generally recommended not to epoch downsampled data,</span>
<span class="sd">                     but instead epoch and then downsample, as epoching</span>
<span class="sd">                     downsampled data jitters triggers.</span>
<span class="sd">                     For more, see</span>
<span class="sd">                     `this illustrative gist &lt;https://gist.github.com/Eric89GXL/01642cb3789992fbca59&gt;`_.</span>

<span class="sd">                     If resampling the continuous data is desired, it is</span>
<span class="sd">                     recommended to construct events using the original data.</span>
<span class="sd">                     The event onsets can be jointly resampled with the raw</span>
<span class="sd">                     data using the &#39;events&#39; parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sfreq : float</span>
<span class="sd">            New sample rate to use.</span>
<span class="sd">        npad : int | str</span>
<span class="sd">            Amount to pad the start and end of the data.</span>
<span class="sd">            Can also be &quot;auto&quot; to use a padding that will result in</span>
<span class="sd">            a power-of-two size (can be much faster).</span>
<span class="sd">        window : string or tuple</span>
<span class="sd">            Frequency-domain window to use in resampling.</span>
<span class="sd">            See :func:`scipy.signal.resample`.</span>
<span class="sd">        stim_picks : array of int | None</span>
<span class="sd">            Stim channels. These channels are simply subsampled or</span>
<span class="sd">            supersampled (without applying any filtering). This reduces</span>
<span class="sd">            resampling artifacts in stim channels, but may lead to missing</span>
<span class="sd">            triggers. If None, stim channels are automatically chosen using</span>
<span class="sd">            :func:`mne.pick_types`.</span>
<span class="sd">        n_jobs : int | str</span>
<span class="sd">            Number of jobs to run in parallel. Can be &#39;cuda&#39; if scikits.cuda</span>
<span class="sd">            is installed properly and CUDA is initialized.</span>
<span class="sd">        events : 2D array, shape (n_events, 3) | None</span>
<span class="sd">            An optional event matrix. When specified, the onsets of the events</span>
<span class="sd">            are resampled jointly with the data.</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more). Defaults to self.verbose.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        raw : instance of Raw</span>
<span class="sd">            The resampled version of the raw object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mne.io.Raw.filter</span>
<span class="sd">        mne.Epochs.resample</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For some data, it may be more accurate to use ``npad=0`` to reduce</span>
<span class="sd">        artifacts. This is dataset dependent -- check your data!</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;raw.resample&#39;</span><span class="p">)</span>

        <span class="c1"># When no event object is supplied, some basic detection of dropped</span>
        <span class="c1"># events is performed to generate a warning. Finding events can fail</span>
        <span class="c1"># for a variety of reasons, e.g. if no stim channel is present or it is</span>
        <span class="c1"># corrupted. This should not stop the resampling from working. The</span>
        <span class="c1"># warning should simply not be generated in this case.</span>
        <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">original_events</span> <span class="o">=</span> <span class="n">find_events</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="n">sfreq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sfreq</span><span class="p">)</span>
        <span class="n">o_sfreq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>

        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_lengths</span><span class="p">)))</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="n">ratio</span> <span class="o">=</span> <span class="n">sfreq</span> <span class="o">/</span> <span class="n">o_sfreq</span>

        <span class="c1"># set up stim channel processing</span>
        <span class="k">if</span> <span class="n">stim_picks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stim_picks</span> <span class="o">=</span> <span class="n">pick_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ref_meg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">stim</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[])</span>
        <span class="n">stim_picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">stim_picks</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_lengths</span><span class="p">)):</span>
            <span class="n">data_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="n">offsets</span><span class="p">[</span><span class="n">ri</span><span class="p">]:</span><span class="n">offsets</span><span class="p">[</span><span class="n">ri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resample</span><span class="p">(</span><span class="n">data_chunk</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">o_sfreq</span><span class="p">,</span> <span class="n">npad</span><span class="p">,</span>
                                     <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">))</span>
            <span class="n">new_ntimes</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># In empirical testing, it was faster to resample all channels</span>
            <span class="c1"># (above) and then replace the stim channels than it was to only</span>
            <span class="c1"># resample the proper subset of channels and then use np.insert()</span>
            <span class="c1"># to restore the stims.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stim_picks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">stim_resampled</span> <span class="o">=</span> <span class="n">_resample_stim_channels</span><span class="p">(</span>
                    <span class="n">data_chunk</span><span class="p">[</span><span class="n">stim_picks</span><span class="p">],</span> <span class="n">new_data</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">data_chunk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">new_data</span><span class="p">[</span><span class="n">ri</span><span class="p">][</span><span class="n">stim_picks</span><span class="p">]</span> <span class="o">=</span> <span class="n">stim_resampled</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_ntimes</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raw_lengths</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ntimes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sfreq</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lowpass&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;lowpass&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;lowpass&#39;</span><span class="p">],</span> <span class="n">sfreq</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_times</span><span class="p">()</span>

        <span class="c1"># See the comment above why we ignore all errors here.</span>
        <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Did we loose events?</span>
                <span class="n">resampled_events</span> <span class="o">=</span> <span class="n">find_events</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resampled_events</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_events</span><span class="p">):</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Resampling of the stim channels caused event &#39;</span>
                         <span class="s1">&#39;information to become unreliable. Consider finding &#39;</span>
                         <span class="s1">&#39;events on the original data and passing the event &#39;</span>
                         <span class="s1">&#39;matrix as a parameter.&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">events</span>

    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Crop raw data file.</span>

<span class="sd">        Limit the data from the raw file to go between specific times. Note</span>
<span class="sd">        that the new tmin is assumed to be t=0 for all subsequently called</span>
<span class="sd">        functions (e.g., time_as_index, or Epochs). New first_samp and</span>
<span class="sd">        last_samp are set accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tmin : float</span>
<span class="sd">            New start time in seconds (must be &gt;= 0).</span>
<span class="sd">        tmax : float | None</span>
<span class="sd">            New end time in seconds of the data (cannot exceed data duration).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        raw : instance of Raw</span>
<span class="sd">            The cropped raw object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_time</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_times</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmax</span> <span class="o">=</span> <span class="n">max_time</span>

        <span class="k">if</span> <span class="n">tmin</span> <span class="o">&gt;</span> <span class="n">tmax</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tmin must be less than tmax&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tmin</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tmin must be &gt;= 0&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tmax</span> <span class="o">&gt;</span> <span class="n">max_time</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tmax must be less than or equal to the max raw &#39;</span>
                             <span class="s1">&#39;time (</span><span class="si">%0.4f</span><span class="s1"> sec)&#39;</span> <span class="o">%</span> <span class="n">max_time</span><span class="p">)</span>

        <span class="n">smin</span><span class="p">,</span> <span class="n">smax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">_time_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span>
                                         <span class="n">sfreq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">][[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">cumul_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_lengths</span><span class="p">,</span>
                                                   <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)))</span>
        <span class="n">cumul_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">cumul_lens</span><span class="p">)</span>
        <span class="n">keepers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">smin</span><span class="p">,</span> <span class="n">cumul_lens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">smax</span><span class="p">,</span> <span class="n">cumul_lens</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">keepers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keepers</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">keepers</span><span class="p">])</span>
        <span class="c1"># Adjust first_samp of first used file!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">smin</span> <span class="o">-</span> <span class="n">cumul_lens</span><span class="p">[</span><span class="n">keepers</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">[</span><span class="n">keepers</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">cumul_lens</span><span class="p">[</span><span class="n">keepers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">smax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_extras</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">ri</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_extras</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">keepers</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">ri</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span><span class="p">)</span>
                           <span class="k">if</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">keepers</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="c1"># slice and copy to avoid the reference to large array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="n">smin</span><span class="p">:</span><span class="n">smax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_times</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">annotations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">onset</span> <span class="o">-=</span> <span class="n">tmin</span>
            <span class="n">BaseRaw</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotations</span><span class="p">,</span> <span class="n">emit_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">buffer_size_sec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">drop_small_buffer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">,</span>
             <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">split_size</span><span class="o">=</span><span class="s1">&#39;2GB&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save raw data to file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : string</span>
<span class="sd">            File name of the new dataset. This has to be a new filename</span>
<span class="sd">            unless data have been preloaded. Filenames should end with</span>
<span class="sd">            raw.fif, raw.fif.gz, raw_sss.fif, raw_sss.fif.gz, raw_tsss.fif</span>
<span class="sd">            or raw_tsss.fif.gz.</span>
<span class="sd">        picks : array-like of int | None</span>
<span class="sd">            Indices of channels to include. If None all channels are kept.</span>
<span class="sd">        tmin : float | None</span>
<span class="sd">            Time in seconds of first sample to save. If None first sample</span>
<span class="sd">            is used.</span>
<span class="sd">        tmax : float | None</span>
<span class="sd">            Time in seconds of last sample to save. If None last sample</span>
<span class="sd">            is used.</span>
<span class="sd">        buffer_size_sec : float | None</span>
<span class="sd">            Size of data chunks in seconds. If None (default), the buffer</span>
<span class="sd">            size of the original file is used.</span>
<span class="sd">        drop_small_buffer : bool</span>
<span class="sd">            Drop or not the last buffer. It is required by maxfilter (SSS)</span>
<span class="sd">            that only accepts raw files with buffers of the same size.</span>
<span class="sd">        proj : bool</span>
<span class="sd">            If True the data is saved with the projections applied (active).</span>

<span class="sd">            .. note:: If ``apply_proj()`` was used to apply the projections,</span>
<span class="sd">                      the projectons will be active even if ``proj`` is False.</span>

<span class="sd">        fmt : str</span>
<span class="sd">            Format to use to save raw data. Valid options are &#39;double&#39;,</span>
<span class="sd">            &#39;single&#39;, &#39;int&#39;, and &#39;short&#39; for 64- or 32-bit float, or 32- or</span>
<span class="sd">            16-bit integers, respectively. It is **strongly** recommended to</span>
<span class="sd">            use &#39;single&#39;, as this is backward-compatible, and is standard for</span>
<span class="sd">            maintaining precision. Note that using &#39;short&#39; or &#39;int&#39; may result</span>
<span class="sd">            in loss of precision, complex data cannot be saved as &#39;short&#39;,</span>
<span class="sd">            and neither complex data types nor real data stored as &#39;double&#39;</span>
<span class="sd">            can be loaded with the MNE command-line tools. See raw.orig_format</span>
<span class="sd">            to determine the format the original data were stored in.</span>
<span class="sd">        overwrite : bool</span>
<span class="sd">            If True, the destination file (if it exists) will be overwritten.</span>
<span class="sd">            If False (default), an error will be raised if the file exists.</span>
<span class="sd">        split_size : string | int</span>
<span class="sd">            Large raw files are automatically split into multiple pieces. This</span>
<span class="sd">            parameter specifies the maximum size of each piece. If the</span>
<span class="sd">            parameter is an integer, it specifies the size in Bytes. It is</span>
<span class="sd">            also possible to pass a human-readable string, e.g., 100MB.</span>

<span class="sd">            .. note:: Due to FIFF file limitations, the maximum split</span>
<span class="sd">                      size is 2GB.</span>

<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more). Defaults to self.verbose.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If Raw is a concatenation of several raw files, **be warned** that</span>
<span class="sd">        only the measurement information from the first raw file is stored.</span>
<span class="sd">        This likely means that certain operations with external tools may not</span>
<span class="sd">        work properly on a saved concatenated file (e.g., probably some</span>
<span class="sd">        or all forms of SSS). It is recommended not to concatenate and</span>
<span class="sd">        then save raw files for this reason.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_fname</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;raw&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;raw.fif&#39;</span><span class="p">,</span> <span class="s1">&#39;raw_sss.fif&#39;</span><span class="p">,</span> <span class="s1">&#39;raw_tsss.fif&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;raw.fif.gz&#39;</span><span class="p">,</span> <span class="s1">&#39;raw_sss.fif.gz&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;raw_tsss.fif.gz&#39;</span><span class="p">))</span>

        <span class="n">split_size</span> <span class="o">=</span> <span class="n">_get_split_size</span><span class="p">(</span><span class="n">split_size</span><span class="p">)</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="ow">and</span> <span class="n">fname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;You cannot save data to the same file.&#39;</span>
                             <span class="s1">&#39; Please use a different filename.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Saving raw file with complex data. Loading with &#39;</span>
                     <span class="s1">&#39;command-line MNE tools will not work.&#39;</span><span class="p">)</span>

        <span class="n">type_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">short</span><span class="o">=</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFT_DAU_PACK16</span><span class="p">,</span>
                         <span class="nb">int</span><span class="o">=</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFT_INT</span><span class="p">,</span>
                         <span class="n">single</span><span class="o">=</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFT_FLOAT</span><span class="p">,</span>
                         <span class="n">double</span><span class="o">=</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFT_DOUBLE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">type_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fmt must be &quot;short&quot;, &quot;int&quot;, &quot;single&quot;, &#39;</span>
                             <span class="s1">&#39;or &quot;double&quot;&#39;</span><span class="p">)</span>
        <span class="n">reset_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">short</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">int</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">double</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">reset_range</span> <span class="o">=</span> <span class="n">reset_dict</span><span class="p">[</span><span class="n">fmt</span><span class="p">]</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="n">type_dict</span><span class="p">[</span><span class="n">fmt</span><span class="p">]</span>

        <span class="n">data_test</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;short&#39;</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">data_test</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Complex data must be saved as &quot;single&quot; or &#39;</span>
                             <span class="s1">&#39;&quot;double&quot;, not &quot;short&quot;&#39;</span><span class="p">)</span>

        <span class="c1"># check for file existence</span>
        <span class="n">_check_fname</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">proj</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
            <span class="n">projector</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">setup_proj</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
            <span class="n">activate_proj</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span>
            <span class="n">projector</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">#</span>
        <span class="c1">#   Set up the reading parameters</span>
        <span class="c1">#</span>

        <span class="c1">#   Convert to samples</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tmin</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]))</span>

        <span class="c1"># &quot;stop&quot; is the first sample *not* to save, so we need +1&#39;s here</span>
        <span class="k">if</span> <span class="n">tmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_as_index</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tmax</span><span class="p">),</span> <span class="n">use_rounding</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">buffer_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_buffer_size</span><span class="p">(</span><span class="n">buffer_size_sec</span><span class="p">)</span>

        <span class="c1"># write the raw file</span>
        <span class="n">_write_raw</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">reset_range</span><span class="p">,</span>
                   <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">projector</span><span class="p">,</span> <span class="n">drop_small_buffer</span><span class="p">,</span>
                   <span class="n">split_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">plot_raw</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">n_channels</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
             <span class="n">bgcolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bad_color</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
             <span class="n">event_color</span><span class="o">=</span><span class="s1">&#39;cyan&#39;</span><span class="p">,</span> <span class="n">scalings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_dc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">show_options</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">highpass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lowpass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filtorder</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">clipping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">show_first_samp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">group_by</span><span class="o">=</span><span class="s1">&#39;type&#39;</span><span class="p">,</span>
             <span class="n">butterfly</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">plot_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">,</span> <span class="n">bgcolor</span><span class="p">,</span>
                        <span class="n">color</span><span class="p">,</span> <span class="n">bad_color</span><span class="p">,</span> <span class="n">event_color</span><span class="p">,</span> <span class="n">scalings</span><span class="p">,</span> <span class="n">remove_dc</span><span class="p">,</span>
                        <span class="n">order</span><span class="p">,</span> <span class="n">show_options</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">show</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">highpass</span><span class="p">,</span>
                        <span class="n">lowpass</span><span class="p">,</span> <span class="n">filtorder</span><span class="p">,</span> <span class="n">clipping</span><span class="p">,</span> <span class="n">show_first_samp</span><span class="p">,</span> <span class="n">proj</span><span class="p">,</span>
                        <span class="n">group_by</span><span class="p">,</span> <span class="n">butterfly</span><span class="p">)</span>

    <span class="nd">@verbose</span>
    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">plot_raw_psd</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot_psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                 <span class="n">proj</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">area_mode</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="n">area_alpha</span><span class="o">=</span><span class="mf">0.33</span><span class="p">,</span>
                 <span class="n">n_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">line_alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spatial_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">xscale</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">plot_raw_psd</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="n">picks</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">area_mode</span><span class="o">=</span><span class="n">area_mode</span><span class="p">,</span>
            <span class="n">area_alpha</span><span class="o">=</span><span class="n">area_alpha</span><span class="p">,</span> <span class="n">n_overlap</span><span class="o">=</span><span class="n">n_overlap</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="n">dB</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="n">average</span><span class="p">,</span>
            <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">line_alpha</span><span class="o">=</span><span class="n">line_alpha</span><span class="p">,</span>
            <span class="n">spatial_colors</span><span class="o">=</span><span class="n">spatial_colors</span><span class="p">,</span> <span class="n">xscale</span><span class="o">=</span><span class="n">xscale</span><span class="p">)</span>

    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">plot_raw_psd_topo</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot_psd_topo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">n_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>
                      <span class="n">fig_facecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">axis_facecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">plot_raw_psd_topo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
                                 <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
                                 <span class="n">n_overlap</span><span class="o">=</span><span class="n">n_overlap</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span>
                                 <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">fig_facecolor</span><span class="o">=</span><span class="n">fig_facecolor</span><span class="p">,</span>
                                 <span class="n">axis_facecolor</span><span class="o">=</span><span class="n">axis_facecolor</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="n">dB</span><span class="p">,</span>
                                 <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                                 <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">estimate_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tstop</span><span class="o">=</span><span class="mf">30.0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
                      <span class="n">return_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scalings</span><span class="o">=</span><span class="s1">&#39;norm&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate rank of the raw data.</span>

<span class="sd">        This function is meant to provide a reasonable estimate of the rank.</span>
<span class="sd">        The true rank of the data depends on many factors, so use at your</span>
<span class="sd">        own risk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tstart : float</span>
<span class="sd">            Start time to use for rank estimation. Default is 0.0.</span>
<span class="sd">        tstop : float | None</span>
<span class="sd">            End time to use for rank estimation. Default is 30.0.</span>
<span class="sd">            If None, the end time of the raw file is used.</span>
<span class="sd">        tol : float</span>
<span class="sd">            Tolerance for singular values to consider non-zero in</span>
<span class="sd">            calculating the rank. The singular values are calculated</span>
<span class="sd">            in this method such that independent data are expected to</span>
<span class="sd">            have singular value around one.</span>
<span class="sd">        return_singular : bool</span>
<span class="sd">            If True, also return the singular values that were used</span>
<span class="sd">            to determine the rank.</span>
<span class="sd">        picks : array_like of int, shape (n_selected_channels,)</span>
<span class="sd">            The channels to be considered for rank estimation.</span>
<span class="sd">            If None (default) meg and eeg channels are included.</span>
<span class="sd">        scalings : dict | &#39;norm&#39;</span>
<span class="sd">            To achieve reliable rank estimation on multiple sensors,</span>
<span class="sd">            sensors have to be rescaled. This parameter controls the</span>
<span class="sd">            rescaling. If dict, it will update the</span>
<span class="sd">            following dict of defaults:</span>

<span class="sd">                dict(mag=1e11, grad=1e9, eeg=1e5)</span>

<span class="sd">            If &#39;norm&#39; data will be scaled by internally computed</span>
<span class="sd">            channel-wise norms.</span>
<span class="sd">            Defaults to &#39;norm&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rank : int</span>
<span class="sd">            Estimated rank of the data.</span>
<span class="sd">        s : array</span>
<span class="sd">            If return_singular is True, the singular values that were</span>
<span class="sd">            thresholded to determine the rank are also returned.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If data are not pre-loaded, the appropriate data will be loaded</span>
<span class="sd">        by this function (can be memory intensive).</span>

<span class="sd">        Projectors are not taken into account unless they have been applied</span>
<span class="sd">        to the data using apply_proj(), since it is not always possible</span>
<span class="sd">        to tell whether or not projectors have been applied previously.</span>

<span class="sd">        Bad channels will be excluded from calculations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..cov</span> <span class="k">import</span> <span class="n">_estimate_rank_meeg_signals</span>

        <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_as_index</span><span class="p">(</span><span class="n">tstart</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">tstop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_times</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_as_index</span><span class="p">(</span><span class="n">tstop</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">tslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">_pick_data_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="s1">&#39;bads&#39;</span><span class="p">,</span>
                                        <span class="n">with_ref_meg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># ensure we don&#39;t get a view of data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span>
        <span class="c1"># this should already be a copy, so we can overwrite it</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">tslice</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">_estimate_rank_meeg_signals</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">pick_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">),</span>
            <span class="n">scalings</span><span class="o">=</span><span class="n">scalings</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">return_singular</span><span class="o">=</span><span class="n">return_singular</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ch_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Channel names.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Time points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of time points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of time points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        len : int</span>
<span class="sd">            The number of time points.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This can be used as::</span>

<span class="sd">            &gt;&gt;&gt; len(raw)  # doctest: +SKIP</span>
<span class="sd">            1000</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span>

    <span class="k">def</span> <span class="nf">load_bad_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bad_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mark channels as bad from a text file.</span>

<span class="sd">        This function operates mostly in the style of the C function</span>
<span class="sd">        ``mne_mark_bad_channels``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bad_file : string</span>
<span class="sd">            File name of the text file containing bad channels</span>
<span class="sd">            If bad_file = None, bad channels are cleared, but this</span>
<span class="sd">            is more easily done directly as raw.info[&#39;bads&#39;] = [].</span>
<span class="sd">        force : boolean</span>
<span class="sd">            Whether or not to force bad channel marking (of those</span>
<span class="sd">            that exist) if channels are not found, instead of</span>
<span class="sd">            raising an error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bad_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check to make sure bad channels are there</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">])</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">bad_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">fid</span><span class="p">:</span>
                <span class="n">bad_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">fid</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span> <span class="k">if</span> <span class="n">l</span><span class="p">]</span>
            <span class="n">names_there</span> <span class="o">=</span> <span class="p">[</span><span class="n">ci</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">bad_names</span> <span class="k">if</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
            <span class="n">count_diff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_names</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">names_there</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">count_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad channels from:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1"> not found &#39;</span>
                                     <span class="s1">&#39;in:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bad_file</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> bad channels from:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1">not found in:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">count_diff</span><span class="p">,</span> <span class="n">bad_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">names_there</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raws</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenate raw instances as if they were continuous.</span>

<span class="sd">        .. note:: Boundaries of the raw files are annotated bad. If you wish to</span>
<span class="sd">                  use the data as continuous recording, you can remove the</span>
<span class="sd">                  boundary annotations after concatenation (see</span>
<span class="sd">                  :meth:`mne.Annotations.delete`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        raws : list, or Raw instance</span>
<span class="sd">            list of Raw instances to concatenate to the current instance</span>
<span class="sd">            (in order), or a single raw instance to concatenate.</span>
<span class="sd">        preload : bool, str, or None (default None)</span>
<span class="sd">            Preload data into memory for data manipulation and faster indexing.</span>
<span class="sd">            If True, the data will be preloaded into memory (fast, requires</span>
<span class="sd">            large amount of memory). If preload is a string, preload is the</span>
<span class="sd">            file name of a memory-mapped file which is used to store the data</span>
<span class="sd">            on the hard drive (slower, requires less memory). If preload is</span>
<span class="sd">            None, preload=True or False is inferred using the preload status</span>
<span class="sd">            of the raw files passed in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raws</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">raws</span> <span class="o">=</span> <span class="p">[</span><span class="n">raws</span><span class="p">]</span>

        <span class="c1"># make sure the raws are compatible</span>
        <span class="n">all_raws</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">all_raws</span> <span class="o">+=</span> <span class="n">raws</span>
        <span class="n">_check_raw_compatibility</span><span class="p">(</span><span class="n">all_raws</span><span class="p">)</span>

        <span class="c1"># deal with preloading data first (while files are separate)</span>
        <span class="n">all_preloaded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">preload</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">raws</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">preload</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">all_preloaded</span><span class="p">:</span>
                <span class="n">preload</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">preload</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">preload</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># do the concatenation ourselves since preload might be a string</span>
            <span class="n">nchan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span>
            <span class="n">c_ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">rr</span><span class="o">.</span><span class="n">n_times</span> <span class="k">for</span> <span class="n">rr</span> <span class="ow">in</span> <span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">raws</span><span class="p">)])</span>
            <span class="n">nsamp</span> <span class="o">=</span> <span class="n">c_ns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
                <span class="n">this_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_segment</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">this_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

            <span class="c1"># allocate the buffer</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preload</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">preload</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">this_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                  <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">this_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">c_ns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">this_data</span>

            <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">raws</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">raws</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
                    <span class="c1"># read the data directly into the buffer</span>
                    <span class="n">data_buffer</span> <span class="o">=</span> <span class="n">_data</span><span class="p">[:,</span> <span class="n">c_ns</span><span class="p">[</span><span class="n">ri</span><span class="p">]:</span><span class="n">c_ns</span><span class="p">[</span><span class="n">ri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                    <span class="n">raws</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">_read_segment</span><span class="p">(</span><span class="n">data_buffer</span><span class="o">=</span><span class="n">data_buffer</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_data</span><span class="p">[:,</span> <span class="n">c_ns</span><span class="p">[</span><span class="n">ri</span><span class="p">]:</span><span class="n">c_ns</span><span class="p">[</span><span class="n">ri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">raws</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># now combine information from each raw file to construct new self</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span>
        <span class="n">edge_samps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">raws</span><span class="p">:</span>
            <span class="n">annotations</span> <span class="o">=</span> <span class="n">_combine_annotations</span><span class="p">((</span><span class="n">annotations</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">annotations</span><span class="p">),</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">],</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_date&#39;</span><span class="p">])</span>
            <span class="n">edge_samps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raw_extras</span> <span class="o">+=</span> <span class="n">r</span><span class="o">.</span><span class="n">_raw_extras</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span> <span class="o">+=</span> <span class="n">r</span><span class="o">.</span><span class="n">_filenames</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_times</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">annotations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">annotations</span> <span class="o">=</span> <span class="n">Annotations</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span> <span class="o">=</span> <span class="n">annotations</span>
        <span class="k">for</span> <span class="n">edge_samp</span> <span class="ow">in</span> <span class="n">edge_samps</span><span class="p">:</span>
            <span class="n">onset</span> <span class="o">=</span> <span class="n">_sync_onset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">edge_samp</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">onset</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]),</span>
                                    <span class="s1">&#39;BAD boundary&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">)</span> <span class="o">==</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_extras</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Append error&#39;</span><span class="p">)</span>  <span class="c1"># should never happen</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clean up the object.</span>

<span class="sd">        Does nothing for objects that close their file descriptors.</span>
<span class="sd">        Things like RawFIF will override this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return copy of Raw instance.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: D105</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">op</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">size_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sizeof_fmt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="p">))</span>  <span class="c1"># str in case it fails -&gt; None</span>
        <span class="n">size_str</span> <span class="o">+=</span> <span class="s1">&#39;, data</span><span class="si">%s</span><span class="s1"> loaded&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="k">else</span> <span class="s1">&#39; not&#39;</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">, n_channels x n_times : </span><span class="si">%s</span><span class="s1"> x </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%0.1f</span><span class="s1"> sec), ~</span><span class="si">%s</span><span class="s1">&#39;</span>
             <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">size_str</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">  |  </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">stim_channel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add events to stim channel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        events : ndarray, shape (n_events, 3)</span>
<span class="sd">            Events to add. The first column specifies the sample number of</span>
<span class="sd">            each event, the second column is ignored, and the third column</span>
<span class="sd">            provides the event value. If events already exist in the Raw</span>
<span class="sd">            instance at the given sample numbers, the event values will be</span>
<span class="sd">            added together.</span>
<span class="sd">        stim_channel : str | None</span>
<span class="sd">            Name of the stim channel to add to. If None, the config variable</span>
<span class="sd">            &#39;MNE_STIM_CHANNEL&#39; is used. If this is not found, it will default</span>
<span class="sd">            to &#39;STI 014&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Data must be preloaded in order to add events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;cannot add events unless data are preloaded&#39;</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">events</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">events</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;events must be shape (n_events, 3)&#39;</span><span class="p">)</span>
        <span class="n">stim_channel</span> <span class="o">=</span> <span class="n">_get_stim_channel</span><span class="p">(</span><span class="n">stim_channel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
        <span class="n">pick</span> <span class="o">=</span> <span class="n">pick_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">,</span> <span class="n">stim_channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pick</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Channel </span><span class="si">%s</span><span class="s1"> not found&#39;</span> <span class="o">%</span> <span class="n">stim_channel</span><span class="p">)</span>
        <span class="n">pick</span> <span class="o">=</span> <span class="n">pick</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;event sample numbers must be between </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1">&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;event sample numbers must be integers&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">pick</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span><span class="p">]</span> <span class="o">+=</span> <span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_buffer_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer_size_sec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the buffer size.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">buffer_size_sec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">buffer_size_sec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;buffer_size_sec&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">buffer_size_sec</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]))</span>


<span class="k">def</span> <span class="nf">_check_preload</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ensure data are preloaded.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">raw</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span> <span class="s1">&#39; requires raw data to be loaded. Use &#39;</span>
                           <span class="s1">&#39;preload=True (or string) in the constructor or &#39;</span>
                           <span class="s1">&#39;raw.load_data().&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_allocate_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_buffer</span><span class="p">,</span> <span class="n">data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Allocate data in memory or in memmap for preloading.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># if not already done, allocate array with right type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_buffer</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="c1"># use a memmap</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">data_buffer</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                             <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">data_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_index_as_time</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">first_samp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_first_samp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert indices to time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    index : list-like | int</span>
<span class="sd">        List of ints or int representing points in time.</span>
<span class="sd">    use_first_samp : boolean</span>
<span class="sd">        If True, the time returned is relative to the session onset, else</span>
<span class="sd">        relative to the recording onset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    times : ndarray</span>
<span class="sd">        Times corresponding to the index supplied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">first_samp</span> <span class="k">if</span> <span class="n">use_first_samp</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">times</span> <span class="o">/</span> <span class="n">sfreq</span>


<span class="k">class</span> <span class="nc">_RawShell</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Create a temporary raw object.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: D102</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rawdir</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_projector</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: D102</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">+</span> <span class="mi">1</span>


<span class="c1">###############################################################################</span>
<span class="c1"># Writing</span>
<span class="k">def</span> <span class="nf">_write_raw</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">reset_range</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
               <span class="n">stop</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">projector</span><span class="p">,</span> <span class="n">drop_small_buffer</span><span class="p">,</span>
               <span class="n">split_size</span><span class="p">,</span> <span class="n">part_idx</span><span class="p">,</span> <span class="n">prev_fname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write raw file with splitting.&quot;&quot;&quot;</span>
    <span class="c1"># we&#39;ve done something wrong if we hit this</span>
    <span class="n">n_times_max</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">stop</span> <span class="ow">or</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">n_times_max</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot write raw file with no data: </span><span class="si">%s</span><span class="s1"> -&gt; </span><span class="si">%s</span><span class="s1"> &#39;</span>
                           <span class="s1">&#39;(max: </span><span class="si">%s</span><span class="s1">) requested&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">n_times_max</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">part_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># insert index in filename</span>
        <span class="n">base</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">use_fname</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-</span><span class="si">%d%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">part_idx</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">use_fname</span> <span class="o">=</span> <span class="n">fname</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Writing </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">use_fname</span><span class="p">)</span>

    <span class="n">fid</span><span class="p">,</span> <span class="n">cals</span> <span class="o">=</span> <span class="n">_start_writing_raw</span><span class="p">(</span><span class="n">use_fname</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span>
                                   <span class="n">reset_range</span><span class="p">,</span> <span class="n">raw</span><span class="o">.</span><span class="n">annotations</span><span class="p">)</span>
    <span class="n">use_picks</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">picks</span>

    <span class="n">first_samp</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">+</span> <span class="n">start</span>
    <span class="k">if</span> <span class="n">first_samp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_FIRST_SAMPLE</span><span class="p">,</span> <span class="n">first_samp</span><span class="p">)</span>

    <span class="c1"># previous file name and id</span>
    <span class="k">if</span> <span class="n">part_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">prev_fname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_REF</span><span class="p">)</span>
        <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_ROLE</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_ROLE_PREV_FILE</span><span class="p">)</span>
        <span class="n">write_string</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_NAME</span><span class="p">,</span> <span class="n">prev_fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">write_id</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_ID</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">])</span>
        <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_NUM</span><span class="p">,</span> <span class="n">part_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_REF</span><span class="p">)</span>

    <span class="n">pos_prev</span> <span class="o">=</span> <span class="n">fid</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">pos_prev</span> <span class="o">&gt;</span> <span class="n">split_size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;file is larger than &quot;split_size&quot; after writing &#39;</span>
                         <span class="s1">&#39;measurement information, you must use a larger &#39;</span>
                         <span class="s1">&#39;value for split size: </span><span class="si">%s</span><span class="s1"> plus enough bytes for &#39;</span>
                         <span class="s1">&#39;the chosen buffer_size&#39;</span> <span class="o">%</span> <span class="n">pos_prev</span><span class="p">)</span>
    <span class="n">next_file_buffer</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">20</span>  <span class="c1"># extra cushion for last few post-data tags</span>
    <span class="k">for</span> <span class="n">first</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">):</span>
        <span class="c1"># Write blocks &lt;= buffer_size in size</span>
        <span class="n">last</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="n">use_picks</span><span class="p">,</span> <span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">==</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span>

        <span class="k">if</span> <span class="n">projector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projector</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">drop_small_buffer</span> <span class="ow">and</span> <span class="p">(</span><span class="n">first</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span> <span class="ow">and</span>
             <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">buffer_size</span><span class="p">))):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Skipping data chunk due to small buffer ... &#39;</span>
                        <span class="s1">&#39;[done]&#39;</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Writing ...&#39;</span><span class="p">)</span>
        <span class="n">_write_raw_buffer</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cals</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">fid</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="n">this_buff_size_bytes</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">pos_prev</span>
        <span class="n">overage</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">split_size</span> <span class="o">+</span> <span class="n">next_file_buffer</span>
        <span class="k">if</span> <span class="n">overage</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># This should occur on the first buffer write of the file, so</span>
            <span class="c1"># we should mention the space required for the meas info</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;buffer size (</span><span class="si">%s</span><span class="s1">) is too large for the given split size (</span><span class="si">%s</span><span class="s1">) &#39;</span>
                <span class="s1">&#39;by </span><span class="si">%s</span><span class="s1"> bytes after writing info (</span><span class="si">%s</span><span class="s1">) and leaving enough space &#39;</span>
                <span class="s1">&#39;for end tags (</span><span class="si">%s</span><span class="s1">): decrease &quot;buffer_size_sec&quot; or increase &#39;</span>
                <span class="s1">&#39;&quot;split_size&quot;.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">this_buff_size_bytes</span><span class="p">,</span> <span class="n">split_size</span><span class="p">,</span> <span class="n">overage</span><span class="p">,</span>
                                   <span class="n">pos_prev</span><span class="p">,</span> <span class="n">next_file_buffer</span><span class="p">))</span>

        <span class="c1"># Split files if necessary, leave some space for next file info</span>
        <span class="c1"># make sure we check to make sure we actually *need* another buffer</span>
        <span class="c1"># with the &quot;and&quot; check</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">split_size</span> <span class="o">-</span> <span class="n">this_buff_size_bytes</span> <span class="o">-</span> <span class="n">next_file_buffer</span> <span class="ow">and</span> \
                <span class="n">first</span> <span class="o">+</span> <span class="n">buffer_size</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
            <span class="n">next_fname</span><span class="p">,</span> <span class="n">next_idx</span> <span class="o">=</span> <span class="n">_write_raw</span><span class="p">(</span>
                <span class="n">fname</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span>
                <span class="n">data_type</span><span class="p">,</span> <span class="n">reset_range</span><span class="p">,</span> <span class="n">first</span> <span class="o">+</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span>
                <span class="n">projector</span><span class="p">,</span> <span class="n">drop_small_buffer</span><span class="p">,</span> <span class="n">split_size</span><span class="p">,</span>
                <span class="n">part_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">use_fname</span><span class="p">)</span>

            <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_REF</span><span class="p">)</span>
            <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_ROLE</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_ROLE_NEXT_FILE</span><span class="p">)</span>
            <span class="n">write_string</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_NAME</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">next_fname</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">write_id</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_ID</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">])</span>
            <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_NUM</span><span class="p">,</span> <span class="n">next_idx</span><span class="p">)</span>
            <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_REF</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="n">pos_prev</span> <span class="o">=</span> <span class="n">pos</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Closing </span><span class="si">%s</span><span class="s1"> [done]&#39;</span> <span class="o">%</span> <span class="n">use_fname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxshield&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_SMSH_RAW_DATA</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_RAW_DATA</span><span class="p">)</span>
    <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MEAS</span><span class="p">)</span>
    <span class="n">end_file</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">use_fname</span><span class="p">,</span> <span class="n">part_idx</span>


<span class="k">def</span> <span class="nf">_start_writing_raw</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">sel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFT_FLOAT</span><span class="p">,</span>
                       <span class="n">reset_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">annotations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Start write raw data in file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : string</span>
<span class="sd">        Name of the file to create.</span>
<span class="sd">    info : dict</span>
<span class="sd">        Measurement info.</span>
<span class="sd">    sel : array of int, optional</span>
<span class="sd">        Indices of channels to include. By default all channels are included.</span>
<span class="sd">    data_type : int</span>
<span class="sd">        The data_type in case it is necessary. Should be 4 (FIFFT_FLOAT),</span>
<span class="sd">        5 (FIFFT_DOUBLE), 16 (FIFFT_DAU_PACK16), or 3 (FIFFT_INT) for raw data.</span>
<span class="sd">    reset_range : bool</span>
<span class="sd">        If True, the info[&#39;chs&#39;][k][&#39;range&#39;] parameter will be set to unity.</span>
<span class="sd">    annotations : instance of Annotations or None</span>
<span class="sd">        The annotations to write.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fid : file</span>
<span class="sd">        The file descriptor.</span>
<span class="sd">    cals : list</span>
<span class="sd">        calibration factors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># Measurement info</span>
    <span class="c1">#</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">pick_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">sel</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Create the file and save the essentials</span>
    <span class="c1">#</span>
    <span class="n">fid</span> <span class="o">=</span> <span class="n">start_file</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MEAS</span><span class="p">)</span>
    <span class="n">write_id</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_BLOCK_ID</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">write_id</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_PARENT_BLOCK_ID</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">])</span>

    <span class="n">cals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]):</span>
        <span class="c1">#</span>
        <span class="c1">#   Scan numbers may have been messed up</span>
        <span class="c1">#</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;scanno&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># scanno starts at 1 in FIF format</span>
        <span class="k">if</span> <span class="n">reset_range</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">cals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;cal&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>

    <span class="n">write_meas_info</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span> <span class="n">reset_range</span><span class="o">=</span><span class="n">reset_range</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Annotations</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">annotations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotations</span><span class="o">.</span><span class="n">onset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MNE_ANNOTATIONS</span><span class="p">)</span>
        <span class="n">write_float</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_MNE_BASELINE_MIN</span><span class="p">,</span> <span class="n">annotations</span><span class="o">.</span><span class="n">onset</span><span class="p">)</span>
        <span class="n">write_float</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_MNE_BASELINE_MAX</span><span class="p">,</span>
                    <span class="n">annotations</span><span class="o">.</span><span class="n">duration</span> <span class="o">+</span> <span class="n">annotations</span><span class="o">.</span><span class="n">onset</span><span class="p">)</span>
        <span class="c1"># To allow : in description, they need to be replaced for serialization</span>
        <span class="n">write_name_list</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_COMMENT</span><span class="p">,</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="s1">&#39;;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span>
                                                 <span class="n">annotations</span><span class="o">.</span><span class="n">description</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">annotations</span><span class="o">.</span><span class="n">orig_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">write_double</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_MEAS_DATE</span><span class="p">,</span> <span class="n">annotations</span><span class="o">.</span><span class="n">orig_time</span><span class="p">)</span>
        <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MNE_ANNOTATIONS</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Start the raw data</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxshield&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_SMSH_RAW_DATA</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_RAW_DATA</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fid</span><span class="p">,</span> <span class="n">cals</span>


<span class="k">def</span> <span class="nf">_write_raw_buffer</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">cals</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write raw buffer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fid : file descriptor</span>
<span class="sd">        an open raw data file.</span>
<span class="sd">    buf : array</span>
<span class="sd">        The buffer to write.</span>
<span class="sd">    cals : array</span>
<span class="sd">        Calibration factors.</span>
<span class="sd">    fmt : str</span>
<span class="sd">        &#39;short&#39;, &#39;int&#39;, &#39;single&#39;, or &#39;double&#39; for 16/32 bit int or 32/64 bit</span>
<span class="sd">        float for each item. This will be doubled for complex datatypes. Note</span>
<span class="sd">        that short and int formats cannot be used for complex data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">buf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cals</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;buffer and calibration sizes do not match&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fmt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;short&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;single&#39;</span><span class="p">,</span> <span class="s1">&#39;double&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fmt must be &quot;short&quot;, &quot;single&quot;, or &quot;double&quot;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">buf</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;short&#39;</span><span class="p">:</span>
            <span class="n">write_function</span> <span class="o">=</span> <span class="n">write_dau_pack16</span>
        <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
            <span class="n">write_function</span> <span class="o">=</span> <span class="n">write_int</span>
        <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
            <span class="n">write_function</span> <span class="o">=</span> <span class="n">write_float</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">write_function</span> <span class="o">=</span> <span class="n">write_double</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
            <span class="n">write_function</span> <span class="o">=</span> <span class="n">write_complex64</span>
        <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;double&#39;</span><span class="p">:</span>
            <span class="n">write_function</span> <span class="o">=</span> <span class="n">write_complex128</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only &quot;single&quot; and &quot;double&quot; supported for &#39;</span>
                             <span class="s1">&#39;writing complex data&#39;</span><span class="p">)</span>

    <span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">cals</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">write_function</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_DATA_BUFFER</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_my_hilbert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">envelope</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute Hilbert transform of signals w/ zero padding.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array, shape (n_times)</span>
<span class="sd">        The signal to convert</span>
<span class="sd">    n_fft : int</span>
<span class="sd">        Size of the FFT to perform, must be at least ``len(x)``.</span>
<span class="sd">        The signal will be cut back to original length.</span>
<span class="sd">    envelope : bool</span>
<span class="sd">        Whether to compute amplitude of the hilbert transform in order</span>
<span class="sd">        to return the signal envelope.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array, shape (n_times)</span>
<span class="sd">        The hilbert transform of the signal, or the envelope.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">hilbert</span>
    <span class="n">n_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)[:</span><span class="n">n_x</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">envelope</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_check_raw_compatibility</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ensure all instances of Raw have compatible parameters.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">],</span> <span class="nb">type</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raw[</span><span class="si">%d</span><span class="s1">] type must match&#39;</span> <span class="o">%</span> <span class="n">ri</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raw[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">nchan</span><span class="se">\&#39;</span><span class="s1">] must match&#39;</span> <span class="o">%</span> <span class="n">ri</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raw[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">bads</span><span class="se">\&#39;</span><span class="s1">] must match&#39;</span> <span class="o">%</span> <span class="n">ri</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raw[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">sfreq</span><span class="se">\&#39;</span><span class="s1">] must match&#39;</span> <span class="o">%</span> <span class="n">ri</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raw[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">ch_names</span><span class="se">\&#39;</span><span class="s1">] must match&#39;</span> <span class="o">%</span> <span class="n">ri</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">_cals</span> <span class="o">==</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_cals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raw[</span><span class="si">%d</span><span class="s1">]._cals must match&#39;</span> <span class="o">%</span> <span class="n">ri</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;SSP projectors in raw files must be the same&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">_proj_equal</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span>
                   <span class="nb">zip</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">],</span> <span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;SSP projectors in raw files must be the same&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">orig_format</span> <span class="o">==</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">orig_format</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">raw</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;raw files do not all have the same data format, could result in &#39;</span>
             <span class="s1">&#39;precision mismatch. Setting raw.orig_format=&quot;unknown&quot;&#39;</span><span class="p">)</span>
        <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">orig_format</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span>


<span class="k">def</span> <span class="nf">concatenate_raws</span><span class="p">(</span><span class="n">raws</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">events_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Concatenate raw instances as if they were continuous.</span>

<span class="sd">    .. note:: ``raws[0]`` is modified in-place to achieve the concatenation.</span>
<span class="sd">              Boundaries of the raw files are annotated bad. If you wish to use</span>
<span class="sd">              the data as continuous recording, you can remove the boundary</span>
<span class="sd">              annotations after concatenation (see</span>
<span class="sd">              :meth:`mne.Annotations.delete`).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raws : list</span>
<span class="sd">        list of Raw instances to concatenate (in order).</span>
<span class="sd">    preload : bool, or None</span>
<span class="sd">        If None, preload status is inferred using the preload status of the</span>
<span class="sd">        raw files passed in. True or False sets the resulting raw file to</span>
<span class="sd">        have or not have data preloaded.</span>
<span class="sd">    events_list : None | list</span>
<span class="sd">        The events to concatenate. Defaults to None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    raw : instance of Raw</span>
<span class="sd">        The result of the concatenation (first Raw instance passed in).</span>
<span class="sd">    events : ndarray of int, shape (n events, 3)</span>
<span class="sd">        The events. Only returned if `event_list` is not None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">events_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">events_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">raws</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`raws` and `event_list` are required &#39;</span>
                             <span class="s1">&#39;to be of the same length&#39;</span><span class="p">)</span>
        <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="n">r</span><span class="o">.</span><span class="n">first_samp</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">last_samp</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">raws</span><span class="p">])</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">concatenate_events</span><span class="p">(</span><span class="n">events_list</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
    <span class="n">raws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">raws</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">preload</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">events_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">raws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">raws</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">events</span>


<span class="k">def</span> <span class="nf">_check_update_montage</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">montage</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update_ch_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Help eeg readers to add montage.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">montage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">montage</span><span class="p">,</span> <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="n">Montage</span><span class="p">)):</span>
            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Montage must be str, None, or instance of Montage. &quot;</span>
                   <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> was provided&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">montage</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">montage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">montage</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">montage</span> <span class="o">=</span> <span class="n">read_montage</span><span class="p">(</span><span class="n">montage</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
            <span class="n">_set_montage</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">montage</span><span class="p">,</span> <span class="n">update_ch_names</span><span class="o">=</span><span class="n">update_ch_names</span><span class="p">)</span>

            <span class="n">missing_positions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">(</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_EOG_CH</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_MISC_CH</span><span class="p">,</span>
                       <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_STIM_CH</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">missing_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;ch_name&#39;</span><span class="p">])</span>

            <span class="c1"># raise error if positions are missing</span>
            <span class="k">if</span> <span class="n">missing_positions</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="s2">&quot;The following positions are missing from the montage &quot;</span>
                    <span class="s2">&quot;definitions: </span><span class="si">%s</span><span class="s2">. If those channels lack positions &quot;</span>
                    <span class="s2">&quot;because they are EOG channels use the eog parameter.&quot;</span>
                    <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">missing_positions</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_check_maxshield</span><span class="p">(</span><span class="n">allow_maxshield</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warn or error about MaxShield.&quot;&quot;&quot;</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;This file contains raw Internal Active &#39;</span>
           <span class="s1">&#39;Shielding data. It may be distorted. Elekta &#39;</span>
           <span class="s1">&#39;recommends it be run through MaxFilter to &#39;</span>
           <span class="s1">&#39;produce reliable results. Consider closing &#39;</span>
           <span class="s1">&#39;the file and running MaxFilter on the data.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">allow_maxshield</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">allow_maxshield</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">allow_maxshield</span> <span class="o">==</span> <span class="s1">&#39;yes&#39;</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">allow_maxshield</span> <span class="o">=</span> <span class="s1">&#39;yes&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39; Use allow_maxshield=True if you are sure you&#39;</span>
                <span class="s1">&#39; want to load the data despite this warning.&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017, Jan Freyberg.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>